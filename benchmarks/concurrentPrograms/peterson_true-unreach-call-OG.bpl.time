[TRACE] Using prover: /home/alexander/sharedData/uni/hice-dt/Boogie/Binaries/z3.exe
Parsing /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Coalescing blocks...
#parameters: 16
#parameters: 16
#parameters: 16
#parameters: 16
#parameters: 16
#parameters: 16
#parameters: 16
#parameters: 16
Generating VC of pre
Generating VC of assert_t1
Generating VC of assert_t2
Generating VC of atomic_t1_transition_s1
Generating VC of atomic_t1_transition_s2
Generating VC of atomic_t1_transition_s3
Generating VC of atomic_t2_transition_s1
Generating VC of atomic_t2_transition_s2
Generating VC of atomic_t2_transition_s3
Generating VC of P0_stable_t2_s1
Generating VC of P1_stable_t2_s1
Generating VC of P2_stable_t2_s1
Generating VC of P3_stable_t2_s1
Generating VC of P0_stable_t2_s2
Generating VC of P1_stable_t2_s2
Generating VC of P2_stable_t2_s2
Generating VC of P3_stable_t2_s2
Generating VC of P0_stable_t2_s3
Generating VC of P1_stable_t2_s3
Generating VC of P2_stable_t2_s3
Generating VC of P3_stable_t2_s3
Generating VC of Q0_stable_t1_s1
Generating VC of Q1_stable_t1_s1
Generating VC of Q2_stable_t1_s1
Generating VC of Q3_stable_t1_s1
Generating VC of Q0_stable_t1_s2
Generating VC of Q1_stable_t1_s2
Generating VC of Q2_stable_t1_s2
Generating VC of Q3_stable_t1_s2
Generating VC of Q0_stable_t1_s3
Generating VC of Q1_stable_t1_s3
Generating VC of Q2_stable_t1_s3
Generating VC of Q3_stable_t1_s3
Generating VC of not_Q1_stable_t1_s1
Generating VC of not_Q1_stable_t1_s2
Generating VC of not_Q1_stable_t1_s3
Generating VC of not_P1_stable_t2_s1
Generating VC of not_P1_stable_t2_s2
Generating VC of not_P1_stable_t2_s3
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.015527
Prover Time taken = 0.001066
Prover Time taken = 0.000656
Prover Time taken = 0.000606
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000812
Prover Time taken = 0.000684
Prover Time taken = 0.000563
Prover Time taken = 0.000657
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000646
Prover Time taken = 0.000553
Prover Time taken = 0.000603
Prover Time taken = 0.000676
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000723
Prover Time taken = 0.000542
Prover Time taken = 0.000624
Prover Time taken = 0.00069
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000645
Prover Time taken = 0.000629
Prover Time taken = 0.000537
Prover Time taken = 0.00055
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000798
Prover Time taken = 0.000659
Prover Time taken = 0.000615
Prover Time taken = 0.000671
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000684
Prover Time taken = 0.000868
Prover Time taken = 0.000775
Prover Time taken = 0.000668
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000599
Prover Time taken = 0.000559
Prover Time taken = 0.000506
Prover Time taken = 0.000553
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Added: Q2:1,2,2,-2: negative
Prover Time taken = 0.107546
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0133080
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.016334
Prover Time taken = 0.013224
Prover Time taken = 0.014185
Prover Time taken = 0.016666
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.020063
Prover Time taken = 0.015149
Prover Time taken = 0.022455
Prover Time taken = 0.023902
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.020077
Prover Time taken = 0.015719
Prover Time taken = 0.015825
Prover Time taken = 0.016638
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.01605
Prover Time taken = 0.015686
Prover Time taken = 0.016857
Prover Time taken = 0.018798
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.016897
Prover Time taken = 0.018338
Prover Time taken = 0.020198
Prover Time taken = 0.016979
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.029201
Prover Time taken = 0.019379
Prover Time taken = 0.022216
Prover Time taken = 0.01706
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.01255
Prover Time taken = 0.010336
Prover Time taken = 0.010169
Prover Time taken = 0.010547
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.018025
Prover Time taken = 0.010433
Prover Time taken = 0.011162
Prover Time taken = 0.009886
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.006489
Prover Time taken = 0.007267
Prover Time taken = 0.006947
Prover Time taken = 0.006623
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.006274
Prover Time taken = 0.005871
Prover Time taken = 0.006841
Prover Time taken = 0.006565
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.014748
Prover Time taken = 0.015251
Prover Time taken = 0.01251
Prover Time taken = 0.012536
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.017358
Prover Time taken = 0.014172
Prover Time taken = 0.01302
Prover Time taken = 0.013059
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.013151
Prover Time taken = 0.012954
Prover Time taken = 0.013124
Prover Time taken = 0.013106
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.014714
Prover Time taken = 0.014531
Prover Time taken = 0.017143
Prover Time taken = 0.014209
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.018295
Prover Time taken = 0.019365
Prover Time taken = 0.015856
Prover Time taken = 0.016338
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.012418
Prover Time taken = 0.008404
Prover Time taken = 0.008629
Prover Time taken = 0.008908
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.013336
Prover Time taken = 0.008493
Prover Time taken = 0.008502
Prover Time taken = 0.008348
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.015576
Prover Time taken = 0.013467
Prover Time taken = 0.012946
Prover Time taken = 0.013773
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.010023
Prover Time taken = 0.009676
Prover Time taken = 0.00975
Prover Time taken = 0.010679
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.01317
Prover Time taken = 0.012785
Prover Time taken = 0.014805
Prover Time taken = 0.013953
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.018726
Prover Time taken = 0.013326
Prover Time taken = 0.012209
Prover Time taken = 0.012014
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.012468
Prover Time taken = 0.015782
Prover Time taken = 0.015699
Prover Time taken = 0.015655
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.012672
Prover Time taken = 0.012313
Prover Time taken = 0.012233
Prover Time taken = 0.015116
Verifying P0_stable_t2_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.015961
Prover Time taken = 0.019601
Prover Time taken = 0.014649
Prover Time taken = 0.013494
Verifying P0_stable_t2_s2: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.02618
Prover Time taken = 0.019439
Prover Time taken = 0.020195
Prover Time taken = 0.020905
Verifying Q0_stable_t1_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.015691
Prover Time taken = 0.016047
Prover Time taken = 0.015852
Prover Time taken = 0.018319
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.018577
Prover Time taken = 0.020393
Prover Time taken = 0.021323
Prover Time taken = 0.022872
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.022395
Prover Time taken = 0.021342
Prover Time taken = 0.017194
Prover Time taken = 0.020381
Verifying Q1_stable_t1_s1: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.017787
Prover Time taken = 0.015932
Prover Time taken = 0.015857
Prover Time taken = 0.023173
Verifying Q1_stable_t1_s3: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.016237
Prover Time taken = 0.018609
Prover Time taken = 0.013901
Prover Time taken = 0.013854
Verifying not_Q1_stable_t1_s1: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.033763
Prover Time taken = 0.017771
Prover Time taken = 0.017962
Prover Time taken = 0.016753
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.016402
Prover Time taken = 0.018888
Prover Time taken = 0.016561
Prover Time taken = 0.015239
Verifying not_Q1_stable_t1_s3: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.021708
Prover Time taken = 0.022112
Prover Time taken = 0.023851
Prover Time taken = 0.022334
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.017892
Prover Time taken = 0.024615
Prover Time taken = 0.017041
Prover Time taken = 0.017505
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.017147
Prover Time taken = 0.016632
Prover Time taken = 0.016031
Prover Time taken = 0.015957
Verifying Q2_stable_t1_s1: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.014014
Prover Time taken = 0.013489
Prover Time taken = 0.013734
Prover Time taken = 0.016335
Verifying Q2_stable_t1_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.012724
Prover Time taken = 0.015623
Prover Time taken = 0.012855
Prover Time taken = 0.012742
Verifying not_P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.015872
Prover Time taken = 0.013575
Prover Time taken = 0.013075
Prover Time taken = 0.016327
Verifying pre: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Added: P0:-2,0,0,0: positive
Prover Time taken = 0.010949
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0112960
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.011473
Prover Time taken = 0.011786
Prover Time taken = 0.013058
Prover Time taken = 0.010055
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009194
Prover Time taken = 0.0079
Prover Time taken = 0.007939
Prover Time taken = 0.016032
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.015442
Added Horn clause: 1 => 2
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0099380
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.011349
Prover Time taken = 0.012243
Prover Time taken = 0.01449
Prover Time taken = 0.009945
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.008423
Added Horn clause: 2 => 3
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0091320
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.012703
Prover Time taken = 0.014007
Prover Time taken = 0.010917
Prover Time taken = 0.010965
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.010501
Added Horn clause: 3 => 4
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0099160
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.010588
Prover Time taken = 0.01132
Prover Time taken = 0.007918
Prover Time taken = 0.01001
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.013359
Prover Time taken = 0.014598
Prover Time taken = 0.015274
Prover Time taken = 0.010337
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.016589
Prover Time taken = 0.012255
Prover Time taken = 0.014504
Prover Time taken = 0.01439
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008135
Prover Time taken = 0.009301
Prover Time taken = 0.006588
Prover Time taken = 0.005996
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.003805
Prover Time taken = 0.003491
Prover Time taken = 0.003625
Prover Time taken = 0.003933
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.006804
Prover Time taken = 0.007153
Prover Time taken = 0.010923
Prover Time taken = 0.006059
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009318
Prover Time taken = 0.009116
Prover Time taken = 0.00918
Prover Time taken = 0.009904
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.011233
Prover Time taken = 0.010603
Prover Time taken = 0.009593
Prover Time taken = 0.012705
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009073
Prover Time taken = 0.008763
Prover Time taken = 0.008972
Prover Time taken = 0.009159
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.012429
Prover Time taken = 0.01058
Prover Time taken = 0.010767
Prover Time taken = 0.01284
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.006888
Added Horn clause: 5 => 6
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0126090
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.011074
Prover Time taken = 0.013091
Prover Time taken = 0.012722
Prover Time taken = 0.010495
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.008451
Prover Time taken = 0.00684
Prover Time taken = 0.006848
Prover Time taken = 0.008506
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.004692
Prover Time taken = 0.006196
Added Horn clause: 7 => 8
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0094550
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.011957
Prover Time taken = 0.009809
Prover Time taken = 0.010321
Prover Time taken = 0.011722
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.00576
Prover Time taken = 0.005959
Prover Time taken = 0.005947
Prover Time taken = 0.005655
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.005004
Prover Time taken = 0.004728
Prover Time taken = 0.005064
Prover Time taken = 0.004326
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.008022
Prover Time taken = 0.007962
Prover Time taken = 0.007476
Prover Time taken = 0.007236
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.008547
Prover Time taken = 0.010759
Prover Time taken = 0.009152
Prover Time taken = 0.008787
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.007968
Prover Time taken = 0.007571
Prover Time taken = 0.007877
Prover Time taken = 0.009742
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.012029
Prover Time taken = 0.010834
Prover Time taken = 0.01076
Prover Time taken = 0.014333
Verifying P0_stable_t2_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.010425
Prover Time taken = 0.008484
Prover Time taken = 0.008318
Prover Time taken = 0.008431
Verifying P0_stable_t2_s2: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009118
Prover Time taken = 0.007893
Prover Time taken = 0.008518
Prover Time taken = 0.00872
Verifying Q0_stable_t1_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.0116
Prover Time taken = 0.011026
Prover Time taken = 0.010817
Prover Time taken = 0.012086
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.012291
Prover Time taken = 0.010486
Prover Time taken = 0.008089
Prover Time taken = 0.01042
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.018151
Prover Time taken = 0.013404
Prover Time taken = 0.013419
Prover Time taken = 0.014585
Verifying Q1_stable_t1_s1: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.012399
Prover Time taken = 0.009772
Prover Time taken = 0.010124
Prover Time taken = 0.010126
Verifying Q1_stable_t1_s3: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.019828
Prover Time taken = 0.01001
Prover Time taken = 0.012218
Prover Time taken = 0.010086
Verifying not_Q1_stable_t1_s1: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.012357
Prover Time taken = 0.01054
Prover Time taken = 0.009748
Prover Time taken = 0.010475
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.012702
Prover Time taken = 0.011585
Prover Time taken = 0.009829
Prover Time taken = 0.009871
Verifying not_Q1_stable_t1_s3: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.017192
Prover Time taken = 0.013254
Prover Time taken = 0.013338
Prover Time taken = 0.009995
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.014104
Prover Time taken = 0.011296
Prover Time taken = 0.008104
Prover Time taken = 0.00733
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.011757
Prover Time taken = 0.012147
Prover Time taken = 0.009883
Prover Time taken = 0.00983
Verifying Q2_stable_t1_s1: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.010264
Prover Time taken = 0.012365
Prover Time taken = 0.010223
Prover Time taken = 0.010217
Verifying Q2_stable_t1_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.011081
Prover Time taken = 0.010411
Prover Time taken = 0.011188
Prover Time taken = 0.010135
Verifying not_P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009467
Prover Time taken = 0.009337
Prover Time taken = 0.007213
Prover Time taken = 0.007231
Verifying pre: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= -1 && x + turn <= 0 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= -1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Added: P0:0,0,0,0: positive
Added: Q0:-1,0,0,0: positive
Prover Time taken = 0.010892
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0091150
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.013396
Prover Time taken = 0.011054
Prover Time taken = 0.018122
Prover Time taken = 0.009937
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.009519
Prover Time taken = 0.007526
Prover Time taken = 0.007308
Prover Time taken = 0.008204
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007973
Prover Time taken = 0.010013
Prover Time taken = 0.009657
Prover Time taken = 0.008312
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009238
Prover Time taken = 0.007908
Prover Time taken = 0.010674
Prover Time taken = 0.009113
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009951
Added Horn clause: 10 => 11
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0120290
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.01729
Prover Time taken = 0.009982
Prover Time taken = 0.006937
Prover Time taken = 0.006919
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007692
Prover Time taken = 0.007674
Prover Time taken = 0.006982
Prover Time taken = 0.008033
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005816
Prover Time taken = 0.005625
Prover Time taken = 0.007965
Prover Time taken = 0.008869
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009672
Added Horn clause: 11 => 12
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0091080
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007948
Prover Time taken = 0.007789
Prover Time taken = 0.007541
Prover Time taken = 0.008897
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && turn <= -1 && turn <= -1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && flag1 <= -1 && flag1 <= -1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && flag2 <= -1 && flag2 <= -1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && -1 < x - turn && x - turn <= 0 && x - turn <= 0 && -1 < x - turn && 0 < x - turn && x - turn <= 1 && x - turn <= 1 && 0 < x - turn && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && turn + flag1 <= -1 && turn + flag1 <= -1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && turn - flag1 <= -1 && turn - flag1 <= -1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && turn + flag2 <= -1 && turn + flag2 <= -1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && turn - flag2 <= -1 && turn - flag2 <= -1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && flag1 + flag2 <= -1 && flag1 + flag2 <= -1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009789
Added Horn clause: 12 => 13
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0085740
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.011929
Prover Time taken = 0.009349
Prover Time taken = 0.011333
Prover Time taken = 0.009505
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.009554
Prover Time taken = 0.008984
Prover Time taken = 0.008284
Prover Time taken = 0.009763
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.008902
Prover Time taken = 0.009173
Prover Time taken = 0.009433
Prover Time taken = 0.009448
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006337
Prover Time taken = 0.008317
Prover Time taken = 0.005917
Prover Time taken = 0.005871
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.003696
Prover Time taken = 0.003593
Prover Time taken = 0.003597
Prover Time taken = 0.003537
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008833
Prover Time taken = 0.009296
Prover Time taken = 0.007833
Prover Time taken = 0.009738
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.00824
Prover Time taken = 0.007973
Prover Time taken = 0.007882
Prover Time taken = 0.007956
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.01001
Prover Time taken = 0.009364
Prover Time taken = 0.009387
Prover Time taken = 0.010083
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= -1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.006107
Added Horn clause: 9 => 14
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0093590
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.015487
Prover Time taken = 0.010089
Prover Time taken = 0.007146
Prover Time taken = 0.01017
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.005122
Prover Time taken = 0.004924
Prover Time taken = 0.004743
Prover Time taken = 0.004783
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.005601
Prover Time taken = 0.004488
Prover Time taken = 0.004963
Prover Time taken = 0.006054
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006947
Prover Time taken = 0.006869
Prover Time taken = 0.009235
Prover Time taken = 0.008578
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008677
Prover Time taken = 0.008524
Prover Time taken = 0.00702
Prover Time taken = 0.008016
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006623
Prover Time taken = 0.008531
Prover Time taken = 0.007703
Prover Time taken = 0.009108
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.007208
Prover Time taken = 0.006791
Prover Time taken = 0.006795
Prover Time taken = 0.009229
Verifying P0_stable_t2_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008221
Added Horn clause: 5 && 10 => 15
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0081350
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.011269
Prover Time taken = 0.006835
Prover Time taken = 0.008546
Prover Time taken = 0.007723
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008301
Prover Time taken = 0.007026
Prover Time taken = 0.005785
Prover Time taken = 0.007618
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.004949
Added Horn clause: 15 => 16
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0094890
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.009491
Prover Time taken = 0.009309
Prover Time taken = 0.009596
Prover Time taken = 0.007372
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.004624
Prover Time taken = 0.004475
Prover Time taken = 0.005178
Prover Time taken = 0.00596
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.003316
Prover Time taken = 0.003266
Prover Time taken = 0.003276
Prover Time taken = 0.003244
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.015864
Prover Time taken = 0.009744
Prover Time taken = 0.008618
Prover Time taken = 0.005684
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008832
Prover Time taken = 0.006099
Prover Time taken = 0.006076
Prover Time taken = 0.005817
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.00722
Prover Time taken = 0.00694
Prover Time taken = 0.008655
Prover Time taken = 0.007096
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008521
Prover Time taken = 0.00788
Prover Time taken = 0.00793
Prover Time taken = 0.010237
Verifying P0_stable_t2_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007047
Prover Time taken = 0.00792
Prover Time taken = 0.006498
Prover Time taken = 0.006255
Verifying P0_stable_t2_s2: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 0 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.009112
Added Horn clause: 15 && 11 => 17
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0090720
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008155
Prover Time taken = 0.006792
Prover Time taken = 0.006567
Prover Time taken = 0.006818
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007485
Added Horn clause: 17 && 12 => 18
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0115510
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && turn + flag2 <= 1 && turn + flag2 <= 1 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && turn - flag2 <= 1 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.009714
Added Horn clause: 13 && 18 => 19
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0074220
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.011311
Prover Time taken = 0.007249
Prover Time taken = 0.005396
Prover Time taken = 0.005605
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 0 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.010009
Added Horn clause: 19 && 14 => 20
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0086390
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005539
Prover Time taken = 0.006217
Prover Time taken = 0.006119
Prover Time taken = 0.00542
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007383
Prover Time taken = 0.006082
Prover Time taken = 0.005734
Prover Time taken = 0.00632
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.007592
Added Horn clause: 20 && 3 => 21
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0086050
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005495
Prover Time taken = 0.005156
Prover Time taken = 0.006068
Prover Time taken = 0.007325
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006034
Prover Time taken = 0.00681
Prover Time taken = 0.006949
Prover Time taken = 0.008172
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.006539
Prover Time taken = 0.006214
Prover Time taken = 0.006178
Prover Time taken = 0.006193
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005147
Prover Time taken = 0.004866
Prover Time taken = 0.004739
Prover Time taken = 0.004639
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006117
Prover Time taken = 0.006221
Prover Time taken = 0.006061
Prover Time taken = 0.005983
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 0 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006264
Added Horn clause: 17 => 22
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0117700
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007365
Prover Time taken = 0.008028
Prover Time taken = 0.005905
Prover Time taken = 0.007934
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.006113
Prover Time taken = 0.006649
Prover Time taken = 0.008301
Prover Time taken = 0.006502
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.00503
Prover Time taken = 0.003662
Prover Time taken = 0.00467
Prover Time taken = 0.004019
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.009509
Prover Time taken = 0.008011
Prover Time taken = 0.007168
Prover Time taken = 0.011333
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007742
Prover Time taken = 0.011296
Prover Time taken = 0.010516
Prover Time taken = 0.009935
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008574
Prover Time taken = 0.010357
Prover Time taken = 0.007923
Prover Time taken = 0.008628
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.010401
Prover Time taken = 0.009573
Prover Time taken = 0.015815
Prover Time taken = 0.01376
Verifying P0_stable_t2_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.009021
Prover Time taken = 0.008915
Prover Time taken = 0.011363
Prover Time taken = 0.008967
Verifying P0_stable_t2_s2: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008301
Prover Time taken = 0.008481
Prover Time taken = 0.010828
Prover Time taken = 0.010133
Verifying Q0_stable_t1_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 0 && turn <= 0 && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= -1 && x + turn <= -1 && -2 < x + turn && x + turn <= 0 && x + turn <= 1 && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 0 && turn + flag1 <= 0 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 0 && turn - flag1 <= 0 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && turn + flag2 <= 0 && turn + flag2 <= 0 && -1 < turn + flag2 && turn + flag2 <= 1 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.009833
Added Horn clause: 10 && 5 => 23
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0120070
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.010938
Prover Time taken = 0.010961
Prover Time taken = 0.010213
Prover Time taken = 0.01499
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006991
Prover Time taken = 0.007198
Prover Time taken = 0.00741
Prover Time taken = 0.007157
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.007984
Prover Time taken = 0.006921
Prover Time taken = 0.00733
Prover Time taken = 0.011735
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= -1 && x + flag1 <= -1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && -2 < x - flag1 && x - flag1 <= -1 && x - flag1 <= -1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006645
Added Horn clause: 23 => 24
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0094100
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.011898
Prover Time taken = 0.012091
Prover Time taken = 0.024082
Prover Time taken = 0.010995
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.014626
Prover Time taken = 0.010787
Prover Time taken = 0.010872
Prover Time taken = 0.009929
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008025
Prover Time taken = 0.005072
Prover Time taken = 0.00705
Prover Time taken = 0.007126
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007085
Prover Time taken = 0.009501
Prover Time taken = 0.009316
Prover Time taken = 0.010352
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007387
Added Horn clause: 6 && 23 => 25
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0121210
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006204
Prover Time taken = 0.00593
Prover Time taken = 0.008541
Prover Time taken = 0.007499
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.006878
Added Horn clause: 26 => 27
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0138090
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.008503
Prover Time taken = 0.009896
Prover Time taken = 0.008955
Prover Time taken = 0.009139
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.010502
Added Horn clause: 27 => 28
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0103690
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.009822
Prover Time taken = 0.008209
Prover Time taken = 0.007109
Prover Time taken = 0.006935
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007952
Prover Time taken = 0.008035
Prover Time taken = 0.007926
Prover Time taken = 0.007314
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.011421
Prover Time taken = 0.010867
Prover Time taken = 0.010616
Prover Time taken = 0.010254
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005164
Prover Time taken = 0.00535
Prover Time taken = 0.005326
Prover Time taken = 0.005751
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.004321
Prover Time taken = 0.003272
Prover Time taken = 0.002989
Prover Time taken = 0.003035
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && 0 < flag1 - flag2 && flag1 - flag2 <= 1 && flag1 - flag2 <= 1 && 0 < flag1 - flag2
}
Prover Time taken = 0.005916
Added Horn clause: 29 => 30
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0124790
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006735
Prover Time taken = 0.006055
Prover Time taken = 0.009496
Prover Time taken = 0.007091
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && 0 < x - flag2 && x - flag2 <= 1 && x - flag2 <= 1 && 0 < x - flag2 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 0 && flag1 + flag2 <= 0 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006575
Added Horn clause: 30 => 31
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0094190
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006682
Prover Time taken = 0.005865
Prover Time taken = 0.005933
Prover Time taken = 0.008336
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006209
Prover Time taken = 0.006545
Prover Time taken = 0.00806
Prover Time taken = 0.007992
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007004
Prover Time taken = 0.006687
Prover Time taken = 0.007607
Prover Time taken = 0.008733
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004072
Prover Time taken = 0.004095
Prover Time taken = 0.004843
Prover Time taken = 0.00517
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.002717
Prover Time taken = 0.002557
Prover Time taken = 0.002492
Prover Time taken = 0.002453
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.00419
Prover Time taken = 0.003863
Prover Time taken = 0.004099
Prover Time taken = 0.00462
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007519
Prover Time taken = 0.005677
Prover Time taken = 0.005638
Prover Time taken = 0.005672
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005968
Prover Time taken = 0.006075
Prover Time taken = 0.006021
Prover Time taken = 0.005886
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008821
Prover Time taken = 0.008708
Prover Time taken = 0.006812
Prover Time taken = 0.006673
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005722
Prover Time taken = 0.005756
Prover Time taken = 0.00588
Prover Time taken = 0.005565
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.003615
Prover Time taken = 0.003261
Prover Time taken = 0.003084
Prover Time taken = 0.0031
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005201
Prover Time taken = 0.005078
Prover Time taken = 0.005185
Prover Time taken = 0.005497
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006474
Prover Time taken = 0.005408
Prover Time taken = 0.005354
Prover Time taken = 0.005371
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006132
Prover Time taken = 0.008019
Prover Time taken = 0.006907
Prover Time taken = 0.006616
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= -1 && x + flag2 <= -1 && -2 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007678
Added Horn clause: 32 && 33 => 34
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0094140
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006854
Prover Time taken = 0.005865
Prover Time taken = 0.009996
Prover Time taken = 0.005986
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007312
Prover Time taken = 0.006672
Prover Time taken = 0.005252
Prover Time taken = 0.004928
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006792
Added Horn clause: 34 && 27 => 35
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0076160
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007831
Prover Time taken = 0.006898
Prover Time taken = 0.006808
Prover Time taken = 0.005084
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005102
Prover Time taken = 0.005193
Prover Time taken = 0.005579
Prover Time taken = 0.004974
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007591
Added Horn clause: 36 && 3 => 37
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0087160
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006091
Prover Time taken = 0.005336
Prover Time taken = 0.004962
Prover Time taken = 0.005163
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007298
Prover Time taken = 0.006627
Prover Time taken = 0.009801
Prover Time taken = 0.006198
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004804
Prover Time taken = 0.004621
Prover Time taken = 0.004441
Prover Time taken = 0.004481
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= -1 && x <= -1 && -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 0 && x + turn <= 0 && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 0 && x + flag2 <= 0 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004976
Added Horn clause: 38 => 39
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0079020
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005936
Prover Time taken = 0.010915
Prover Time taken = 0.011474
Prover Time taken = 0.007427
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006508
Prover Time taken = 0.006905
Prover Time taken = 0.006854
Prover Time taken = 0.006793
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x + turn <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && x - flag2 <= -1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006154
Added Horn clause: 37 => 40
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0087510
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && x + flag1 <= 1 && x + flag1 <= 1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && 0 < x - flag1 && x - flag1 <= 1 && x - flag1 <= 1 && 0 < x - flag1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.009453
Added Horn clause: 31 && 40 => 41
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0086880
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005369
Prover Time taken = 0.005774
Prover Time taken = 0.007652
Prover Time taken = 0.006585
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006413
Prover Time taken = 0.00592
Prover Time taken = 0.006408
Prover Time taken = 0.006207
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.010082
Added Horn clause: 41 && 12 => 42
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0090710
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.010139
Prover Time taken = 0.004853
Prover Time taken = 0.006557
Prover Time taken = 0.005089
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006836
Prover Time taken = 0.007464
Prover Time taken = 0.007077
Prover Time taken = 0.005608
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006509
Prover Time taken = 0.00665
Prover Time taken = 0.007228
Prover Time taken = 0.008073
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004005
Prover Time taken = 0.003835
Prover Time taken = 0.003891
Prover Time taken = 0.004122
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005704
Prover Time taken = 0.005587
Prover Time taken = 0.005325
Prover Time taken = 0.005282
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x + flag1 <= 1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004712
Added Horn clause: 34 => 43
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0105640
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005398
Prover Time taken = 0.005939
Prover Time taken = 0.005203
Prover Time taken = 0.007284
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006288
Prover Time taken = 0.005222
Prover Time taken = 0.006122
Prover Time taken = 0.007778
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004031
Prover Time taken = 0.00402
Prover Time taken = 0.003864
Prover Time taken = 0.003826
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007286
Prover Time taken = 0.006765
Prover Time taken = 0.005264
Prover Time taken = 0.00525
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004813
Prover Time taken = 0.004396
Prover Time taken = 0.004429
Prover Time taken = 0.006093
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005215
Prover Time taken = 0.004963
Prover Time taken = 0.004951
Prover Time taken = 0.004949
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004758
Prover Time taken = 0.004612
Prover Time taken = 0.00459
Prover Time taken = 0.005738
Verifying P0_stable_t2_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004734
Prover Time taken = 0.004499
Prover Time taken = 0.004455
Prover Time taken = 0.006122
Verifying P0_stable_t2_s2: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006078
Prover Time taken = 0.005007
Prover Time taken = 0.004831
Prover Time taken = 0.005037
Verifying Q0_stable_t1_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004974
Prover Time taken = 0.007269
Prover Time taken = 0.00553
Prover Time taken = 0.00563
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005682
Prover Time taken = 0.005107
Prover Time taken = 0.004546
Prover Time taken = 0.006785
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 1 && x - flag1 <= -1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.005656
Prover Time taken = 0.005399
Prover Time taken = 0.006123
Prover Time taken = 0.005868
Verifying Q1_stable_t1_s1: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && x <= 1 && -2 < turn && -1 < turn && turn <= 1 && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && x + turn <= 1 && x - turn <= 0 && x - turn <= 1 && x + flag1 <= 0 && x + flag1 <= 1 && x - flag1 <= 0 && x - flag1 <= 1 && x + flag2 <= 1 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && turn + flag1 <= 1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007325
Added Horn clause: 44 && 17 => 45
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0099770
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007038
Prover Time taken = 0.005324
Prover Time taken = 0.006031
Prover Time taken = 0.006231
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && 0 < x && x <= 1 && x <= 1 && 0 < x && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006721
Added Horn clause: 46 && 47 => 48
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0090550
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= -1 && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && -2 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && -1 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && 0 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006069
Prover Time taken = 0.007704
Prover Time taken = 0.00552
Prover Time taken = 0.006663
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.006719
Added Horn clause: 48 => 49
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0116010
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 0 && flag2 <= 0 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && x + flag2 <= 1 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Prover Time taken = 0.004805
Prover Time taken = 0.00468
Prover Time taken = 0.004466
Prover Time taken = 0.004819
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.007363
Prover Time taken = 0.005382
Prover Time taken = 0.005431
Prover Time taken = 0.005193
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 0 && x <= 0 && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && turn <= 1 && turn <= 1 && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && 0 < flag2 && flag2 <= 1 && flag2 <= 1 && 0 < flag2 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x + turn <= 1 && x + turn <= 1 && 0 < x + turn && -2 < x - turn && x - turn <= -1 && x - turn <= -1 && -2 < x - turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 0 && x + flag1 <= 0 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 0 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && x + flag2 <= 1 && x + flag2 <= 1 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= -1 && x - flag2 <= -1 && -2 < x - flag2 && x - flag2 <= 0 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && turn + flag1 <= 1 && turn + flag1 <= 1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && turn - flag2 <= 0 && turn - flag2 <= 0 && -1 < turn - flag2 && turn - flag2 <= 1 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && flag1 + flag2 <= 1 && flag1 + flag2 <= 1 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && flag1 - flag2 <= -1 && flag1 - flag2 <= -1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.008645
Prover Time taken = 0.006905
Prover Time taken = 0.006627
Prover Time taken = 0.008545
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && flag1 <= 0 && flag1 <= 0 && -1 < flag1 && flag1 <= 1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && x + flag1 <= 1 && -2 < x - flag1 && -1 < x - flag1 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && 0 < turn - flag1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && flag1 + flag2 <= 1 && -2 < flag1 - flag2 && flag1 - flag2 <= 0 && flag1 - flag2 <= 1
}
Prover Time taken = 0.003763
Prover Time taken = 0.003698
Prover Time taken = 0.005752
Prover Time taken = 0.004816
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -2 < x && -1 < x && x <= 1 && -2 < turn && -1 < turn && 0 < turn && -2 < flag1 && -1 < flag1 && 0 < flag1 && flag1 <= 1 && flag1 <= 1 && 0 < flag1 && -2 < flag2 && -1 < flag2 && flag2 <= 1 && -2 < x + turn && -1 < x + turn && 0 < x + turn && x - turn <= 0 && x - turn <= 1 && -2 < x + flag1 && -1 < x + flag1 && 0 < x + flag1 && -2 < x - flag1 && x - flag1 <= 0 && x - flag1 <= 1 && -2 < x + flag2 && -1 < x + flag2 && 0 < x + flag2 && -2 < x - flag2 && x - flag2 <= 1 && -2 < turn + flag1 && -1 < turn + flag1 && 0 < turn + flag1 && -2 < turn - flag1 && -1 < turn - flag1 && turn - flag1 <= 1 && -2 < turn + flag2 && -1 < turn + flag2 && 0 < turn + flag2 && -2 < turn - flag2 && -1 < turn - flag2 && -2 < flag1 + flag2 && -1 < flag1 + flag2 && 0 < flag1 + flag2 && -2 < flag1 - flag2 && -1 < flag1 - flag2 && flag1 - flag2 <= 1
}
Overwrote: P2:0,2,1,1: negative
Prover Time taken = 0.004811
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0092220
Verifying Q3_stable_t1_s1: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000916
Prover Time taken = 0.000874
Prover Time taken = 0.000917
Prover Time taken = 0.000684
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000679
Prover Time taken = 0.000694
Prover Time taken = 0.000892
Prover Time taken = 0.001398
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && flag2 <= 0) || (0 < x && 0 < flag2 && turn - flag1 <= 0)
}
Prover Time taken = 0.000948
Prover Time taken = 0.001124
Prover Time taken = 0.000805
Prover Time taken = 0.000781
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000651
Prover Time taken = 0.000577
Prover Time taken = 0.000605
Prover Time taken = 0.000874
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000717
Prover Time taken = 0.000671
Prover Time taken = 0.000691
Prover Time taken = 0.00081
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000644
Prover Time taken = 0.00069
Prover Time taken = 0.000643
Prover Time taken = 0.000656
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000661
Prover Time taken = 0.000816
Prover Time taken = 0.000564
Prover Time taken = 0.000682
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && flag2 <= 0) || (0 < x && 0 < flag2 && turn - flag1 <= 0)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000793
Prover Time taken = 0.002697
Prover Time taken = 0.001033
Prover Time taken = 0.000814
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000743
Prover Time taken = 0.000569
Prover Time taken = 0.000587
Prover Time taken = 0.000575
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && flag2 <= 0) || (0 < x && 0 < flag2 && turn - flag1 <= 0)
}
Prover Time taken = 0.000796
Prover Time taken = 0.000835
Prover Time taken = 0.001102
Prover Time taken = 0.000695
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && flag2 <= 0) || (0 < x && 0 < flag2 && turn - flag1 <= 0)
}
Prover Time taken = 0.002263
Added Horn clause: 50 => 51
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0089680
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && flag2 <= 0)
}
Prover Time taken = 0.000975
Prover Time taken = 0.000911
Prover Time taken = 0.000721
Prover Time taken = 0.000741
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && flag2 <= 0)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000699
Prover Time taken = 0.00068
Prover Time taken = 0.000791
Prover Time taken = 0.000699
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && flag2 <= 0)
}
Prover Time taken = 0.000811
Prover Time taken = 0.00074
Prover Time taken = 0.000773
Prover Time taken = 0.000804
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && flag2 <= 0)
}
Prover Time taken = 0.002245
Added Horn clause: 52 => 53
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0086570
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && turn - flag1 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && flag2 <= 0)
}
Prover Time taken = 0.001054
Prover Time taken = 0.000978
Prover Time taken = 0.00089
Prover Time taken = 0.000853
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && turn - flag1 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && flag2 <= 0)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00081
Prover Time taken = 0.000762
Prover Time taken = 0.00066
Prover Time taken = 0.000875
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && turn - flag1 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && flag2 <= 0)
}
Prover Time taken = 0.000946
Prover Time taken = 0.000809
Prover Time taken = 0.000811
Prover Time taken = 0.000813
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && turn - flag1 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && flag2 <= 0)
}
Prover Time taken = 0.003103
Added Horn clause: 54 => 55
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0082540
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && turn - flag1 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && flag2 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.001067
Prover Time taken = 0.000857
Prover Time taken = 0.001247
Prover Time taken = 0.000901
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && turn - flag1 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && flag2 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000863
Prover Time taken = 0.001106
Prover Time taken = 0.000797
Prover Time taken = 0.000774
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && turn - flag1 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && flag2 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.00097
Prover Time taken = 0.001229
Prover Time taken = 0.001028
Prover Time taken = 0.00111
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && turn - flag1 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && flag2 <= 0) || (0 < x && 1 < turn && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.001227
Prover Time taken = 0.002777
Added Horn clause: 56 => 57
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0120160
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && flag2 <= 1 && flag2 <= 0) || (0 < x && 1 < turn && 1 < flag2)
}
Prover Time taken = 0.001187
Prover Time taken = 0.000988
Prover Time taken = 0.001001
Prover Time taken = 0.00111
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && flag2 <= 1 && flag2 <= 0) || (0 < x && 1 < turn && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00087
Prover Time taken = 0.000829
Prover Time taken = 0.000909
Prover Time taken = 0.000905
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && flag2 <= 1 && flag2 <= 0) || (0 < x && 1 < turn && 1 < flag2)
}
Prover Time taken = 0.000901
Prover Time taken = 0.000949
Prover Time taken = 0.000943
Prover Time taken = 0.000939
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn <= 1) || (0 < x && 1 < turn && flag2 <= 1 && flag2 <= 0) || (0 < x && 1 < turn && 1 < flag2)
}
Prover Time taken = 0.0011
Prover Time taken = 0.002621
Added Horn clause: 58 => 59
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0086840
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x - flag1 <= 0 && turn - flag1 <= 0) || (0 < x && x - flag1 <= 0 && 0 < turn - flag1 && flag2 <= 0) || (0 < x && x - flag1 <= 0 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (0 < x && 0 < x - flag1)
}
Prover Time taken = 0.001522
Prover Time taken = 0.001257
Prover Time taken = 0.001192
Prover Time taken = 0.001371
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x - flag1 <= 0 && turn - flag1 <= 0) || (0 < x && x - flag1 <= 0 && 0 < turn - flag1 && flag2 <= 0) || (0 < x && x - flag1 <= 0 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (0 < x && 0 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001261
Prover Time taken = 0.001392
Prover Time taken = 0.001142
Prover Time taken = 0.001149
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x - flag1 <= 0 && turn - flag1 <= 0) || (0 < x && x - flag1 <= 0 && 0 < turn - flag1 && flag2 <= 0) || (0 < x && x - flag1 <= 0 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (0 < x && 0 < x - flag1)
}
Prover Time taken = 0.001445
Prover Time taken = 0.001038
Prover Time taken = 0.00114
Prover Time taken = 0.001861
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x - flag1 <= 0 && turn - flag1 <= 0) || (0 < x && x - flag1 <= 0 && 0 < turn - flag1 && flag2 <= 0) || (0 < x && x - flag1 <= 0 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (0 < x && 0 < x - flag1)
}
Prover Time taken = 0.001414
Prover Time taken = 0.002737
Added Horn clause: 60 => 61
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0091780
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 - flag2 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 0 < flag1 - flag2) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.001541
Prover Time taken = 0.001089
Prover Time taken = 0.000978
Prover Time taken = 0.000983
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 - flag2 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 0 < flag1 - flag2) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001169
Prover Time taken = 0.000962
Prover Time taken = 0.002474
Prover Time taken = 0.001347
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 - flag2 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 0 < flag1 - flag2) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.001089
Prover Time taken = 0.001003
Prover Time taken = 0.001193
Prover Time taken = 0.001102
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 - flag2 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 0 < flag1 - flag2) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.001345
Prover Time taken = 0.002839
Added Horn clause: 62 => 63
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0091110
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && flag2 <= 1 && flag2 <= 0) || (0 < x && flag2 <= 1 && 0 < flag2 && turn + flag1 <= -1) || (0 < x && flag2 <= 1 && 0 < flag2 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < x && 1 < flag2)
}
Prover Time taken = 0.001458
Prover Time taken = 0.001385
Prover Time taken = 0.001317
Prover Time taken = 0.001328
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && flag2 <= 1 && flag2 <= 0) || (0 < x && flag2 <= 1 && 0 < flag2 && turn + flag1 <= -1) || (0 < x && flag2 <= 1 && 0 < flag2 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < x && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001242
Prover Time taken = 0.001138
Prover Time taken = 0.001076
Prover Time taken = 0.001103
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && flag2 <= 1 && flag2 <= 0) || (0 < x && flag2 <= 1 && 0 < flag2 && turn + flag1 <= -1) || (0 < x && flag2 <= 1 && 0 < flag2 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < x && 1 < flag2)
}
Prover Time taken = 0.0015
Prover Time taken = 0.001204
Prover Time taken = 0.001138
Prover Time taken = 0.001309
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && flag2 <= 1 && flag2 <= 0) || (0 < x && flag2 <= 1 && 0 < flag2 && turn + flag1 <= -1) || (0 < x && flag2 <= 1 && 0 < flag2 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < x && 1 < flag2)
}
Prover Time taken = 0.003164
Added Horn clause: 64 => 65
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0097130
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.00202
Prover Time taken = 0.002044
Prover Time taken = 0.00179
Prover Time taken = 0.001686
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001596
Prover Time taken = 0.001503
Prover Time taken = 0.00145
Prover Time taken = 0.001547
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.001859
Prover Time taken = 0.001515
Prover Time taken = 0.001268
Prover Time taken = 0.001358
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.00216
Prover Time taken = 0.001587
Prover Time taken = 0.002186
Prover Time taken = 0.001836
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00216
Prover Time taken = 0.002379
Prover Time taken = 0.002624
Prover Time taken = 0.002224
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003808
Added Horn clause: 66 && 67 => 68
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0113500
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn - flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && x <= 1 && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.001807
Prover Time taken = 0.001624
Prover Time taken = 0.001337
Prover Time taken = 0.001602
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn - flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && x <= 1 && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001706
Prover Time taken = 0.001966
Prover Time taken = 0.002135
Prover Time taken = 0.001865
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn - flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && x <= 1 && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.002033
Prover Time taken = 0.0022
Prover Time taken = 0.002155
Prover Time taken = 0.001901
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn - flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && x <= 1 && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.001702
Prover Time taken = 0.002067
Prover Time taken = 0.003117
Prover Time taken = 0.001833
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn - flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && x <= 1 && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00233
Prover Time taken = 0.002393
Prover Time taken = 0.002505
Prover Time taken = 0.002356
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn - flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && x <= 1 && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && x <= 1 && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.004056
Added Horn clause: 53 && 69 => 68
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0099660
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.001907
Prover Time taken = 0.001676
Prover Time taken = 0.001268
Prover Time taken = 0.001982
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002148
Prover Time taken = 0.001352
Prover Time taken = 0.002722
Prover Time taken = 0.001475
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Added: P2:0,-2,2,2: negative
Prover Time taken = 0.003076
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0120690
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < turn + flag1 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.001673
Prover Time taken = 0.0014
Prover Time taken = 0.001409
Prover Time taken = 0.003104
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < turn + flag1 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001769
Prover Time taken = 0.001543
Prover Time taken = 0.001553
Prover Time taken = 0.001478
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < turn + flag1 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Added: P2:-2,2,2,-2: negative
Prover Time taken = 0.003326
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0116330
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < turn + flag2 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.001715
Prover Time taken = 0.001366
Prover Time taken = 0.001326
Prover Time taken = 0.001407
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < turn + flag2 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001389
Prover Time taken = 0.001305
Prover Time taken = 0.001273
Prover Time taken = 0.001473
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < turn + flag2 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Added: P2:-2,2,2,-1: negative
Prover Time taken = 0.003661
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0138490
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 - flag2 <= 0 && 0 < turn + flag1 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Prover Time taken = 0.002061
Prover Time taken = 0.001455
Prover Time taken = 0.001476
Prover Time taken = 0.001469
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 - flag2 <= 0 && 0 < turn + flag1 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001352
Prover Time taken = 0.001293
Prover Time taken = 0.001321
Prover Time taken = 0.002974
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 - flag2 <= 0 && 0 < turn + flag1 && turn - flag1 <= 0) || (0 < x && turn - flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && flag2 <= 0) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && turn - flag2 <= 1 && 0 < flag2 && 1 < flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && flag1 <= 1 && 1 < turn - flag2) || (0 < x && 0 < turn - flag2 && x - flag1 <= 0 && 1 < flag1) || (0 < x && 0 < turn - flag2 && 0 < x - flag1)
}
Overwrote: P2:0,2,2,2: negative
Prover Time taken = 0.003489
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0100660
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001032
Prover Time taken = 0.000767
Prover Time taken = 0.000939
Prover Time taken = 0.000651
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && turn - flag2 <= 0) || (flag2 <= 1 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001087
Prover Time taken = 0.001049
Prover Time taken = 0.001072
Prover Time taken = 0.000985
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00056
Prover Time taken = 0.000525
Prover Time taken = 0.000587
Prover Time taken = 0.00056
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.000581
Prover Time taken = 0.000543
Prover Time taken = 0.000559
Prover Time taken = 0.000605
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.000551
Prover Time taken = 0.000505
Prover Time taken = 0.0005
Prover Time taken = 0.00062
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000939
Prover Time taken = 0.000908
Prover Time taken = 0.001053
Prover Time taken = 0.00105
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && turn - flag2 <= 0) || (flag2 <= 1 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.003187
Added Horn clause: 73 && 74 => 75
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0102190
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < turn && turn - flag2 <= 0) || (flag2 <= 1 && 0 < turn && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.0014
Prover Time taken = 0.00088
Prover Time taken = 0.000822
Prover Time taken = 0.000893
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < turn && turn - flag2 <= 0) || (flag2 <= 1 && 0 < turn && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.002777
Added Horn clause: 76 && 77 => 78
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0108060
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && flag1 - flag2 <= 0 && turn - flag2 <= 0) || (flag2 <= 1 && flag1 - flag2 <= 0 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001063
Prover Time taken = 0.001183
Prover Time taken = 0.001082
Prover Time taken = 0.001111
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && flag1 - flag2 <= 0 && turn - flag2 <= 0) || (flag2 <= 1 && flag1 - flag2 <= 0 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.00493
Added Horn clause: 79 && 80 => 81
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0108780
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < turn && flag1 - flag2 <= 0 && turn - flag2 <= 0) || (flag2 <= 1 && 0 < turn && flag1 - flag2 <= 0 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001079
Prover Time taken = 0.000972
Prover Time taken = 0.001218
Prover Time taken = 0.000863
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < turn && flag1 - flag2 <= 0 && turn - flag2 <= 0) || (flag2 <= 1 && 0 < turn && flag1 - flag2 <= 0 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.002847
Added Horn clause: 82 && 83 => 84
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0112860
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && x <= 0) || (flag2 <= 1 && 0 < x && x - flag2 <= 0 && flag1 - flag2 <= 0 && turn - flag2 <= 0)
}
Prover Time taken = 0.002361
Prover Time taken = 0.001284
Prover Time taken = 0.00115
Prover Time taken = 0.001107
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && x <= 0) || (flag2 <= 1 && 0 < x && x - flag2 <= 0 && flag1 - flag2 <= 0 && turn - flag2 <= 0)
}
Prover Time taken = 0.00338
Added Horn clause: 85 && 86 => 87
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0116990
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && x <= 0) || (flag2 <= 1 && 0 < x && x - flag2 <= 0 && -1 < turn - flag1 && turn - flag2 <= 0)
}
Prover Time taken = 0.001218
Prover Time taken = 0.001311
Prover Time taken = 0.003222
Prover Time taken = 0.001053
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && x <= 0) || (flag2 <= 1 && 0 < x && x - flag2 <= 0 && -1 < turn - flag1 && turn - flag2 <= 0)
}
Prover Time taken = 0.002867
Added Horn clause: 88 && 89 => 90
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0138590
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && x <= 0) || (flag2 <= 1 && 0 < x && x - flag2 <= 0 && 0 < turn && turn - flag2 <= 0 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001086
Prover Time taken = 0.000851
Prover Time taken = 0.000872
Prover Time taken = 0.001289
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && x <= 0) || (flag2 <= 1 && 0 < x && x - flag2 <= 0 && 0 < turn && turn - flag2 <= 0 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.003407
Added Horn clause: 65 && 40 => 84
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0120780
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || 0 < x
}
Prover Time taken = 0.001092
Prover Time taken = 0.000974
Prover Time taken = 0.000866
Prover Time taken = 0.000701
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && turn - flag2 <= 0 && flag1 - flag2 <= 0 && flag1 <= 0 && x + flag2 <= 0) || (flag2 <= 1 && turn - flag2 <= 0 && flag1 - flag2 <= 0 && flag1 <= 0 && 0 < x + flag2 && 0 < x) || (flag2 <= 1 && turn - flag2 <= 0 && flag1 - flag2 <= 0 && 0 < flag1)
}
Prover Time taken = 0.001183
Prover Time taken = 0.001012
Prover Time taken = 0.001431
Prover Time taken = 0.001082
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001266
Prover Time taken = 0.000896
Prover Time taken = 0.000742
Prover Time taken = 0.00076
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || 0 < x
}
Added: P2:0,-2,0,-2: negative
Prover Time taken = 0.002358
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0127870
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 - flag2 <= -1) || 0 < x
}
Prover Time taken = 0.001104
Prover Time taken = 0.001006
Prover Time taken = 0.00091
Prover Time taken = 0.000921
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 - flag2 <= -1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000808
Prover Time taken = 0.000791
Prover Time taken = 0.000756
Prover Time taken = 0.000772
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 - flag2 <= -1) || 0 < x
}
Added: P2:0,2,-2,-1: negative
Prover Time taken = 0.003185
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0144710
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < flag2 && flag1 <= 0) || (x <= 0 && -1 < flag2 && 0 < flag1 && 0 < flag1 - flag2) || 0 < x
}
Prover Time taken = 0.001038
Prover Time taken = 0.000941
Prover Time taken = 0.000967
Prover Time taken = 0.000886
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && turn - flag2 <= 0) || (flag2 <= 1 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.000813
Prover Time taken = 0.00077
Prover Time taken = 0.000833
Prover Time taken = 0.000985
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < flag2 && flag1 <= 0) || (x <= 0 && -1 < flag2 && 0 < flag1 && 0 < flag1 - flag2) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00088
Prover Time taken = 0.000705
Prover Time taken = 0.000673
Prover Time taken = 0.000888
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < flag2 && flag1 <= 0) || (x <= 0 && -1 < flag2 && 0 < flag1 && 0 < flag1 - flag2) || 0 < x
}
Added: P2:-2,-2,0,0: negative
Prover Time taken = 0.00245
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0123850
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 - flag2 <= -1 && x - flag1 <= 0) || 0 < x
}
Prover Time taken = 0.001115
Prover Time taken = 0.000949
Prover Time taken = 0.000947
Prover Time taken = 0.000935
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && turn - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 + flag2 && flag1 <= 0 && x + flag2 <= 0) || (flag2 <= 1 && turn - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 + flag2 && flag1 <= 0 && 0 < x + flag2 && 0 < x) || (flag2 <= 1 && turn - flag2 <= 0 && flag1 - flag2 <= 0 && -1 < flag1 + flag2 && 0 < flag1)
}
Prover Time taken = 0.001524
Prover Time taken = 0.001207
Prover Time taken = 0.001671
Prover Time taken = 0.001104
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 - flag2 <= -1 && x - flag1 <= 0) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000831
Prover Time taken = 0.000672
Prover Time taken = 0.000926
Prover Time taken = 0.000684
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 - flag2 <= -1 && x - flag1 <= 0) || 0 < x
}
Added: P2:0,-2,1,2: negative
Prover Time taken = 0.002397
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0138310
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && -1 < flag2) || 0 < x
}
Prover Time taken = 0.001134
Prover Time taken = 0.001056
Prover Time taken = 0.001096
Prover Time taken = 0.000947
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && turn - flag2 <= 0 && flag1 - flag2 <= 0 && flag1 <= 0 && x + flag2 <= 0) || (flag2 <= 1 && turn - flag2 <= 0 && flag1 - flag2 <= 0 && flag1 <= 0 && 0 < x + flag2 && 0 < x) || (flag2 <= 1 && turn - flag2 <= 0 && flag1 - flag2 <= 0 && 0 < flag1)
}
Prover Time taken = 0.001102
Prover Time taken = 0.001332
Prover Time taken = 0.001064
Prover Time taken = 0.001081
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && -1 < flag2) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000785
Prover Time taken = 0.000674
Prover Time taken = 0.000866
Prover Time taken = 0.000792
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && -1 < flag2) || 0 < x
}
Added: P2:-2,-2,-2,2: negative
Prover Time taken = 0.005486
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0135160
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < x + flag2) || 0 < x
}
Prover Time taken = 0.000954
Prover Time taken = 0.000956
Prover Time taken = 0.000802
Prover Time taken = 0.000747
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < x + flag2) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001148
Prover Time taken = 0.000912
Prover Time taken = 0.00086
Prover Time taken = 0.000774
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < x + flag2) || 0 < x
}
Overwrote: P2:0,-2,0,1: negative
Prover Time taken = 0.004039
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0132080
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < x + turn && turn <= 1) || 0 < x
}
Prover Time taken = 0.001129
Prover Time taken = 0.000911
Prover Time taken = 0.000866
Prover Time taken = 0.000761
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && 0 < turn && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && 0 < turn && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001174
Prover Time taken = 0.001259
Prover Time taken = 0.001285
Prover Time taken = 0.001515
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < x + turn && turn <= 1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000804
Prover Time taken = 0.000704
Prover Time taken = 0.000577
Prover Time taken = 0.000595
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < x + turn && turn <= 1) || 0 < x
}
Added: P2:0,1,2,-2: negative
Prover Time taken = 0.002578
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0198880
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < turn + flag1) || 0 < x
}
Prover Time taken = 0.001137
Prover Time taken = 0.000713
Prover Time taken = 0.000711
Prover Time taken = 0.000928
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && -1 < flag1 + flag2 && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && -1 < flag1 + flag2 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001337
Prover Time taken = 0.001681
Prover Time taken = 0.001553
Prover Time taken = 0.001467
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < turn + flag1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000908
Prover Time taken = 0.001011
Prover Time taken = 0.000848
Prover Time taken = 0.001026
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < turn + flag1) || 0 < x
}
Added: P2:0,2,0,2: negative
Prover Time taken = 0.003038
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0134700
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < turn + flag1 && turn <= 1) || 0 < x
}
Prover Time taken = 0.001196
Prover Time taken = 0.001064
Prover Time taken = 0.000903
Prover Time taken = 0.001213
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < turn + flag1 && turn <= 1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000888
Prover Time taken = 0.000698
Prover Time taken = 0.002478
Prover Time taken = 0.000795
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < turn + flag1 && turn <= 1) || 0 < x
}
Added: P2:-2,1,0,2: negative
Prover Time taken = 0.002639
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0140830
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && 0 < turn - flag1 && turn <= 1) || 0 < x
}
Prover Time taken = 0.001075
Prover Time taken = 0.000864
Prover Time taken = 0.000963
Prover Time taken = 0.000924
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && 0 < turn - flag1 && turn <= 1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001198
Prover Time taken = 0.00093
Prover Time taken = 0.000888
Prover Time taken = 0.000932
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && 0 < turn - flag1 && turn <= 1) || 0 < x
}
Added: P2:-2,-1,-2,-2: negative
Prover Time taken = 0.002707
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0135320
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && -1 < turn + flag2) || 0 < x
}
Prover Time taken = 0.001017
Prover Time taken = 0.000858
Prover Time taken = 0.001258
Prover Time taken = 0.001323
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001429
Prover Time taken = 0.000976
Prover Time taken = 0.001067
Prover Time taken = 0.001248
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && -1 < turn + flag2) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000895
Prover Time taken = 0.000915
Prover Time taken = 0.000753
Prover Time taken = 0.00071
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && -1 < turn + flag2) || 0 < x
}
Added: P2:0,-1,0,1: negative
Prover Time taken = 0.002334
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0178140
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && -1 < turn && turn <= 1 && 0 < x + flag2) || 0 < x
}
Prover Time taken = 0.001262
Prover Time taken = 0.000812
Prover Time taken = 0.000759
Prover Time taken = 0.000947
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && -1 < turn && turn <= 1 && 0 < x + flag2) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001113
Prover Time taken = 0.00095
Prover Time taken = 0.000904
Prover Time taken = 0.000934
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && -1 < turn && turn <= 1 && 0 < x + flag2) || 0 < x
}
Added: P2:0,1,-2,1: negative
Prover Time taken = 0.003609
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0140260
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < turn + flag1 && flag2 <= 1) || 0 < x
}
Prover Time taken = 0.001209
Prover Time taken = 0.000919
Prover Time taken = 0.000832
Prover Time taken = 0.000859
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && -1 < flag1 + flag2 && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && -1 < flag1 + flag2 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001038
Prover Time taken = 0.000989
Prover Time taken = 0.001208
Prover Time taken = 0.001108
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < turn + flag1 && flag2 <= 1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001043
Prover Time taken = 0.000824
Prover Time taken = 0.000747
Prover Time taken = 0.000732
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < turn + flag1 && flag2 <= 1) || 0 < x
}
Added: P2:-2,2,0,-2: negative
Prover Time taken = 0.002563
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0159250
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && -1 < turn && turn <= 1) || 0 < x
}
Prover Time taken = 0.001111
Prover Time taken = 0.001066
Prover Time taken = 0.000971
Prover Time taken = 0.001067
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && -1 < turn && turn <= 1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000807
Prover Time taken = 0.000682
Prover Time taken = 0.000838
Prover Time taken = 0.000786
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && -1 < turn && turn <= 1) || 0 < x
}
Added: P2:0,0,0,2: negative
Prover Time taken = 0.002516
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0141220
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && 0 < turn && turn <= 1) || 0 < x
}
Prover Time taken = 0.001221
Prover Time taken = 0.001008
Prover Time taken = 0.00082
Prover Time taken = 0.000824
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && 0 < turn && turn <= 1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000977
Prover Time taken = 0.000684
Prover Time taken = 0.000755
Prover Time taken = 0.000777
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && 0 < turn && turn <= 1) || 0 < x
}
Added: P2:-2,1,-2,2: negative
Prover Time taken = 0.002639
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0173490
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < x + turn && turn <= 1 && 0 < flag1 + flag2) || 0 < x
}
Prover Time taken = 0.000886
Prover Time taken = 0.000756
Prover Time taken = 0.000814
Prover Time taken = 0.000827
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && 0 < turn && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && 0 < turn && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.000919
Prover Time taken = 0.001099
Prover Time taken = 0.000999
Prover Time taken = 0.000887
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < x + turn && turn <= 1 && 0 < flag1 + flag2) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000939
Prover Time taken = 0.00095
Prover Time taken = 0.000991
Prover Time taken = 0.00091
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < x + turn && turn <= 1 && 0 < flag1 + flag2) || 0 < x
}
Added: P2:0,1,2,-1: negative
Prover Time taken = 0.002568
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0163620
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && 0 < x + turn && turn <= 1) || 0 < x
}
Prover Time taken = 0.001443
Prover Time taken = 0.001017
Prover Time taken = 0.001492
Prover Time taken = 0.001295
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && -1 < flag1 + flag2 && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && -1 < flag1 + flag2 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001286
Prover Time taken = 0.001315
Prover Time taken = 0.001067
Prover Time taken = 0.000937
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && 0 < x + turn && turn <= 1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00081
Prover Time taken = 0.000761
Prover Time taken = 0.00084
Prover Time taken = 0.001114
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x - flag1 && x - flag1 <= 0 && 0 < x + turn && turn <= 1) || 0 < x
}
Added: P2:0,1,0,-2: negative
Prover Time taken = 0.002335
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0163620
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && turn + flag1 <= -1 && 0 < x - flag1 && turn <= 0) || (x <= 0 && flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && -1 < turn + flag1) || 0 < x
}
Prover Time taken = 0.001244
Prover Time taken = 0.000975
Prover Time taken = 0.001026
Prover Time taken = 0.002826
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && flag1 - flag2 <= 0 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001388
Prover Time taken = 0.001125
Prover Time taken = 0.001285
Prover Time taken = 0.001119
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && turn + flag1 <= -1 && 0 < x - flag1 && turn <= 0) || (x <= 0 && flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && -1 < turn + flag1) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001292
Prover Time taken = 0.001195
Prover Time taken = 0.001134
Prover Time taken = 0.001154
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && turn + flag1 <= -1 && 0 < x - flag1 && turn <= 0) || (x <= 0 && flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && -1 < turn + flag1) || 0 < x
}
Added: P2:0,-2,-1,1: negative
Prover Time taken = 0.003176
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0145760
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < x + turn && turn <= 1 && 0 < turn + flag2 && x - flag1 <= 0) || 0 < x
}
Prover Time taken = 0.001099
Prover Time taken = 0.001193
Prover Time taken = 0.000974
Prover Time taken = 0.000943
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && 0 < turn && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && 0 < turn && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001089
Prover Time taken = 0.001551
Prover Time taken = 0.001126
Prover Time taken = 0.000998
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < x + turn && turn <= 1 && 0 < turn + flag2 && x - flag1 <= 0) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000849
Prover Time taken = 0.000801
Prover Time taken = 0.000983
Prover Time taken = 0.000865
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < x + turn && turn <= 1 && 0 < turn + flag2 && x - flag1 <= 0) || 0 < x
}
Added: P2:0,1,0,0: negative
Prover Time taken = 0.003032
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0140160
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < flag2 && flag2 <= 1 && turn + flag1 <= -1 && 1 < x - flag1 && turn <= 0) || (x <= 0 && 0 < flag2 && flag2 <= 1 && -1 < turn + flag1 && turn - flag2 <= 0) || 0 < x
}
Prover Time taken = 0.001185
Prover Time taken = 0.000906
Prover Time taken = 0.001447
Prover Time taken = 0.000954
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001045
Prover Time taken = 0.001048
Prover Time taken = 0.001306
Prover Time taken = 0.001164
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < flag2 && flag2 <= 1 && turn + flag1 <= -1 && 1 < x - flag1 && turn <= 0) || (x <= 0 && 0 < flag2 && flag2 <= 1 && -1 < turn + flag1 && turn - flag2 <= 0) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000924
Prover Time taken = 0.000832
Prover Time taken = 0.001221
Prover Time taken = 0.000973
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < flag2 && flag2 <= 1 && turn + flag1 <= -1 && 1 < x - flag1 && turn <= 0) || (x <= 0 && 0 < flag2 && flag2 <= 1 && -1 < turn + flag1 && turn - flag2 <= 0) || 0 < x
}
Overwrote: P2:0,-2,-2,1: negative
Prover Time taken = 0.002966
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0178840
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < turn && turn <= 1 && 0 < x + flag2 && x - flag1 <= 0) || 0 < x
}
Prover Time taken = 0.001195
Prover Time taken = 0.001018
Prover Time taken = 0.000989
Prover Time taken = 0.00114
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && 0 < turn && turn - flag2 <= 0) || (flag2 <= 1 && -1 < turn + flag2 && 0 < turn && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001222
Prover Time taken = 0.001135
Prover Time taken = 0.001242
Prover Time taken = 0.001165
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < turn && turn <= 1 && 0 < x + flag2 && x - flag1 <= 0) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001077
Prover Time taken = 0.000792
Prover Time taken = 0.000954
Prover Time taken = 0.000731
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && 0 < turn && turn <= 1 && 0 < x + flag2 && x - flag1 <= 0) || 0 < x
}
Added: P2:-1,1,-1,2: negative
Prover Time taken = 0.002784
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0145550
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x && 1 < turn + flag2 && flag2 <= 1 && turn - flag2 <= 0 && x - flag1 <= 0) || 0 < x
}
Prover Time taken = 0.001455
Prover Time taken = 0.001234
Prover Time taken = 0.001797
Prover Time taken = 0.001293
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && -1 < turn + flag2 && turn - flag2 <= 0 && 0 < turn && flag1 <= 0 && x + turn <= 0) || (flag2 <= 1 && -1 < turn + flag2 && turn - flag2 <= 0 && 0 < turn && flag1 <= 0 && 0 < x + turn && 0 < x) || (flag2 <= 1 && -1 < turn + flag2 && turn - flag2 <= 0 && 0 < turn && 0 < flag1)
}
Prover Time taken = 0.001554
Prover Time taken = 0.001762
Prover Time taken = 0.001103
Prover Time taken = 0.0011
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x && 1 < turn + flag2 && flag2 <= 1 && turn - flag2 <= 0 && x - flag1 <= 0) || 0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000829
Prover Time taken = 0.000875
Prover Time taken = 0.000875
Prover Time taken = 0.000746
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && -1 < x && 1 < turn + flag2 && flag2 <= 1 && turn - flag2 <= 0 && x - flag1 <= 0) || 0 < x
}
Overwrote: P2:0,1,0,1: negative
Prover Time taken = 0.002742
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0138780
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001018
Prover Time taken = 0.000772
Prover Time taken = 0.001194
Prover Time taken = 0.000977
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && turn <= 1)
}
Prover Time taken = 0.000838
Prover Time taken = 0.000805
Prover Time taken = 0.000731
Prover Time taken = 0.00075
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && flag2 <= 1 && x <= 0) || (-1 < x && flag2 <= 1 && 0 < x && x - flag2 <= 0 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.00151
Prover Time taken = 0.001159
Prover Time taken = 0.001259
Prover Time taken = 0.001445
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000793
Prover Time taken = 0.000693
Prover Time taken = 0.000637
Prover Time taken = 0.000663
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.000743
Prover Time taken = 0.000638
Prover Time taken = 0.000633
Prover Time taken = 0.000664
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.000782
Prover Time taken = 0.000668
Prover Time taken = 0.000659
Prover Time taken = 0.000806
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && turn <= 1)
}
Prover Time taken = 0.001126
Prover Time taken = 0.001076
Prover Time taken = 0.001155
Prover Time taken = 0.001092
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && flag2 <= 1 && x <= 0) || (-1 < x && flag2 <= 1 && 0 < x && x - flag2 <= 0 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.003227
Prover Time taken = 0.001883
Prover Time taken = 0.002114
Prover Time taken = 0.001657
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.00106
Prover Time taken = 0.000986
Prover Time taken = 0.000951
Prover Time taken = 0.001064
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && turn <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001159
Prover Time taken = 0.000959
Prover Time taken = 0.000879
Prover Time taken = 0.001173
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && turn <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && flag2 <= 1 && x <= 0) || (-1 < x && flag2 <= 1 && 0 < x && x - flag2 <= 0 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.002936
Added Horn clause: 110 => 111
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0139010
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn <= 1)
}
Prover Time taken = 0.001019
Prover Time taken = 0.00085
Prover Time taken = 0.000863
Prover Time taken = 0.000737
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && flag2 <= 1 && x <= 0) || (-1 < x && flag2 <= 1 && 0 < x && x - flag2 <= 0 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0) || (-1 < x && flag2 <= 1 && 0 < x && 0 < x - flag2 && 0 < turn && x + flag1 <= 0)
}
Prover Time taken = 0.001465
Prover Time taken = 0.001155
Prover Time taken = 0.001075
Prover Time taken = 0.001154
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn <= 1)
}
Prover Time taken = 0.001029
Prover Time taken = 0.000872
Prover Time taken = 0.001036
Prover Time taken = 0.001372
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && flag2 <= 1 && x <= 0) || (-1 < x && flag2 <= 1 && 0 < x && x - flag2 <= 0 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0) || (-1 < x && flag2 <= 1 && 0 < x && 0 < x - flag2 && 0 < turn && x + flag1 <= 0)
}
Prover Time taken = 0.003728
Added Horn clause: 112 && 113 => 114
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0207360
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && x <= 0) || (-1 < x && x <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 1 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0) || (-1 < x && 1 < x && 0 < x - flag2 && 0 < turn && x + flag1 <= 0)
}
Prover Time taken = 0.001904
Prover Time taken = 0.00153
Prover Time taken = 0.001361
Prover Time taken = 0.001498
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && x <= 0) || (-1 < x && x <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 1 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0) || (-1 < x && 1 < x && 0 < x - flag2 && 0 < turn && x + flag1 <= 0)
}
Prover Time taken = 0.003624
Added Horn clause: 115 && 116 => 117
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0200030
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && x <= 0) || (-1 < x && x <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 1 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0) || (-1 < x && 1 < x && 0 < x - flag2 && x + flag1 <= 0 && 0 < turn && 0 < x - turn)
}
Prover Time taken = 0.001756
Prover Time taken = 0.001683
Prover Time taken = 0.002515
Prover Time taken = 0.001758
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && x <= 0) || (-1 < x && x <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 1 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0) || (-1 < x && 1 < x && 0 < x - flag2 && x + flag1 <= 0 && 0 < turn && 0 < x - turn)
}
Prover Time taken = 0.003796
Added Horn clause: 118 && 111 => 101
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0155150
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn - flag2 <= 1)
}
Prover Time taken = 0.000998
Prover Time taken = 0.00079
Prover Time taken = 0.001108
Prover Time taken = 0.000832
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && x <= 0) || (-1 < x && x <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 1 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001215
Prover Time taken = 0.001546
Prover Time taken = 0.001017
Prover Time taken = 0.000996
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn - flag2 <= 1)
}
Prover Time taken = 0.000971
Prover Time taken = 0.000904
Prover Time taken = 0.001415
Prover Time taken = 0.001545
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && x <= 0) || (-1 < x && x <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 1 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001811
Prover Time taken = 0.001285
Prover Time taken = 0.001473
Prover Time taken = 0.001353
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn - flag2 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001279
Prover Time taken = 0.001087
Prover Time taken = 0.000982
Prover Time taken = 0.000986
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn - flag2 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && x <= 0) || (-1 < x && x <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 1 && 0 < turn && turn - flag2 <= 0 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.002992
Added Horn clause: 119 => 111
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0173470
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && 0 < x + flag2 && turn <= 1)
}
Prover Time taken = 0.001144
Prover Time taken = 0.001076
Prover Time taken = 0.000952
Prover Time taken = 0.001014
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && -1 < flag2 && flag2 <= 1 && -1 < x + turn && flag1 - flag2 <= 0 && turn - flag1 <= 0)
}
Prover Time taken = 0.001284
Prover Time taken = 0.001386
Prover Time taken = 0.001053
Prover Time taken = 0.000987
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && 0 < x + flag2 && turn <= 1)
}
Prover Time taken = 0.001424
Prover Time taken = 0.001402
Prover Time taken = 0.001288
Prover Time taken = 0.001303
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && -1 < flag2 && flag2 <= 1 && -1 < x + turn && flag1 - flag2 <= 0 && turn - flag1 <= 0)
}
Prover Time taken = 0.005146
Added Horn clause: 120 && 121 => 122
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0164650
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && -1 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001354
Prover Time taken = 0.001358
Prover Time taken = 0.001068
Prover Time taken = 0.001028
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && -1 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001237
Prover Time taken = 0.001313
Prover Time taken = 0.001471
Prover Time taken = 0.001919
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && 0 < x + flag2 && turn <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001165
Prover Time taken = 0.00136
Prover Time taken = 0.001257
Prover Time taken = 0.001057
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && 0 < x + flag2 && turn <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && -1 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.002891
Added Horn clause: 123 => 111
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0157660
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && x - flag1 <= 1 && turn <= 1)
}
Prover Time taken = 0.001354
Prover Time taken = 0.001374
Prover Time taken = 0.00127
Prover Time taken = 0.001189
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && x <= 0) || (-1 < x && x <= 1 && 0 < turn && 0 < x && turn <= 1 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001211
Prover Time taken = 0.001406
Prover Time taken = 0.000947
Prover Time taken = 0.000932
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && x - flag1 <= 1 && turn <= 1)
}
Prover Time taken = 0.001245
Prover Time taken = 0.001112
Prover Time taken = 0.001091
Prover Time taken = 0.001376
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && x <= 0) || (-1 < x && x <= 1 && 0 < turn && 0 < x && turn <= 1 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.003502
Added Horn clause: 124 && 125 => 126
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0165970
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && x <= 0) || (-1 < x && x <= 1 && 0 < turn && 0 < x && turn <= 1 && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001218
Prover Time taken = 0.000997
Prover Time taken = 0.001023
Prover Time taken = 0.000975
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && x <= 0) || (-1 < x && x <= 1 && 0 < turn && 0 < x && turn <= 1 && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001836
Prover Time taken = 0.001558
Prover Time taken = 0.001998
Prover Time taken = 0.001685
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && x - flag1 <= 1 && turn <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.003178
Added Horn clause: 127 && 128 => 129
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0157470
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn - flag2 <= 1 && x - turn <= 0)
}
Prover Time taken = 0.00098
Prover Time taken = 0.000884
Prover Time taken = 0.00093
Prover Time taken = 0.000844
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn - flag2 <= 1 && x - turn <= 0)
}
Prover Time taken = 0.001232
Prover Time taken = 0.001578
Prover Time taken = 0.00252
Prover Time taken = 0.001341
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn - flag2 <= 1 && x - turn <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001316
Prover Time taken = 0.001119
Prover Time taken = 0.001249
Prover Time taken = 0.00115
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x + flag2 <= -1 || (-1 < x + flag2 && turn - flag2 <= 1 && x - turn <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && x <= 0) || (-1 < x && x <= 1 && 0 < turn && 0 < x && turn <= 1 && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.003234
Added Horn clause: 130 => 131
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0192280
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && turn - flag2 <= 1 && x - turn <= 0 && flag2 <= 0)
}
Prover Time taken = 0.001149
Prover Time taken = 0.001316
Prover Time taken = 0.001028
Prover Time taken = 0.001016
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && x - turn <= -1 && x <= 0) || (-1 < x && x <= 1 && 0 < turn && -1 < x - turn && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001372
Prover Time taken = 0.001079
Prover Time taken = 0.001221
Prover Time taken = 0.001444
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && turn - flag2 <= 1 && x - turn <= 0 && flag2 <= 0)
}
Prover Time taken = 0.001389
Prover Time taken = 0.00122
Prover Time taken = 0.00102
Prover Time taken = 0.001011
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && x - turn <= -1 && x <= 0) || (-1 < x && x <= 1 && 0 < turn && -1 < x - turn && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001494
Prover Time taken = 0.001501
Prover Time taken = 0.00173
Prover Time taken = 0.001478
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && turn - flag2 <= 1 && x - turn <= 0 && flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001156
Prover Time taken = 0.00107
Prover Time taken = 0.001043
Prover Time taken = 0.001118
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && turn - flag2 <= 1 && x - turn <= 0 && flag2 <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 1 && 0 < turn && x - turn <= -1 && x <= 0) || (-1 < x && x <= 1 && 0 < turn && -1 < x - turn && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0)
}
Prover Time taken = 0.003495
Added Horn clause: 35 => 40
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0191250
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && flag1 <= 0) || (x <= -1 && 0 < flag1 && 0 < x + turn)
}
Prover Time taken = 0.000976
Prover Time taken = 0.001104
Prover Time taken = 0.000764
Prover Time taken = 0.000939
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.000895
Prover Time taken = 0.00084
Prover Time taken = 0.000975
Prover Time taken = 0.000863
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && flag1 <= 0) || (x <= -1 && 0 < flag1 && 0 < x + turn)
}
Prover Time taken = 0.001384
Prover Time taken = 0.001199
Prover Time taken = 0.001776
Prover Time taken = 0.001226
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001067
Prover Time taken = 0.000918
Prover Time taken = 0.000981
Prover Time taken = 0.000994
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && flag1 <= 0) || (x <= -1 && 0 < flag1 && 0 < x + turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001676
Prover Time taken = 0.001675
Prover Time taken = 0.001596
Prover Time taken = 0.001567
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && flag1 <= 0) || (x <= -1 && 0 < flag1 && 0 < x + turn)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.003408
Prover Time taken = 0.001359
Prover Time taken = 0.001377
Prover Time taken = 0.001482
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.00072
Prover Time taken = 0.000567
Prover Time taken = 0.000553
Prover Time taken = 0.000704
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000677
Prover Time taken = 0.000628
Prover Time taken = 0.000932
Prover Time taken = 0.00078
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000894
Prover Time taken = 0.000678
Prover Time taken = 0.000761
Prover Time taken = 0.000838
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && flag1 <= 0) || (x <= -1 && 0 < flag1 && 0 < x + turn)
}
Prover Time taken = 0.000884
Prover Time taken = 0.00094
Prover Time taken = 0.000961
Prover Time taken = 0.00111
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.000918
Prover Time taken = 0.000813
Prover Time taken = 0.000952
Prover Time taken = 0.000836
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000729
Prover Time taken = 0.000584
Prover Time taken = 0.000603
Prover Time taken = 0.000782
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && flag1 <= 0) || (x <= -1 && 0 < flag1 && 0 < x + turn)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003161
Added Horn clause: 132 && 133 => 134
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0181300
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag1 <= 0 && turn - flag2 <= 0) || (x + flag2 <= -1 && 0 < turn - flag1)
}
Prover Time taken = 0.001052
Prover Time taken = 0.000997
Prover Time taken = 0.001194
Prover Time taken = 0.001135
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag1 <= 0 && turn - flag2 <= 0) || (x + flag2 <= -1 && 0 < turn - flag1)
}
Prover Time taken = 0.001241
Prover Time taken = 0.001223
Prover Time taken = 0.00124
Prover Time taken = 0.001083
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag1 <= 0 && turn - flag2 <= 0) || (x + flag2 <= -1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002941
Added Horn clause: 135 && 136 => 137
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0169680
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag2 <= 0) || (x + flag2 <= -1 && 0 < turn - flag2 && 0 < x + turn)
}
Prover Time taken = 0.001584
Prover Time taken = 0.001214
Prover Time taken = 0.000915
Prover Time taken = 0.001048
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag2 <= 0) || (x + flag2 <= -1 && 0 < turn - flag2 && 0 < x + turn)
}
Prover Time taken = 0.00115
Prover Time taken = 0.001167
Prover Time taken = 0.000969
Prover Time taken = 0.000989
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag2 <= 0) || (x + flag2 <= -1 && 0 < turn - flag2 && 0 < x + turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.00156
Prover Time taken = 0.002083
Prover Time taken = 0.001706
Prover Time taken = 0.001587
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag2 <= 0) || (x + flag2 <= -1 && 0 < turn - flag2 && 0 < x + turn)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002554
Added Horn clause: 138 => 139
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0213260
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag1 <= 0 && turn <= 0 && -1 < turn - flag2) || (x + flag2 <= -1 && 0 < turn - flag1)
}
Prover Time taken = 0.001264
Prover Time taken = 0.000903
Prover Time taken = 0.001222
Prover Time taken = 0.001003
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag1 <= 0 && turn <= 0 && -1 < turn - flag2) || (x + flag2 <= -1 && 0 < turn - flag1)
}
Prover Time taken = 0.001258
Prover Time taken = 0.001426
Prover Time taken = 0.001412
Prover Time taken = 0.001465
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn - flag1 <= 0 && turn <= 0 && -1 < turn - flag2) || (x + flag2 <= -1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001657
Prover Time taken = 0.003308
Added Horn clause: 140 && 141 => 142
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0199850
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < x + turn)
}
Prover Time taken = 0.001034
Prover Time taken = 0.001102
Prover Time taken = 0.000991
Prover Time taken = 0.000995
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < x + turn)
}
Prover Time taken = 0.001223
Prover Time taken = 0.001237
Prover Time taken = 0.001117
Prover Time taken = 0.001959
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < x + turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002392
Prover Time taken = 0.001377
Prover Time taken = 0.001462
Prover Time taken = 0.001502
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < x + turn)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002572
Added Horn clause: 143 => 144
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0225130
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < turn - flag1)
}
Prover Time taken = 0.001212
Prover Time taken = 0.001456
Prover Time taken = 0.000935
Prover Time taken = 0.000943
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < turn - flag1)
}
Prover Time taken = 0.001713
Prover Time taken = 0.001705
Prover Time taken = 0.001855
Prover Time taken = 0.001984
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001989
Prover Time taken = 0.001935
Prover Time taken = 0.002097
Prover Time taken = 0.001423
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.004138
Added Horn clause: 145 => 39
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0200290
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 1 < turn + flag2)
}
Prover Time taken = 0.001354
Prover Time taken = 0.000905
Prover Time taken = 0.000841
Prover Time taken = 0.000982
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 1 < turn + flag2)
}
Prover Time taken = 0.001219
Prover Time taken = 0.001062
Prover Time taken = 0.00108
Prover Time taken = 0.0013
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 1 < turn + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001712
Prover Time taken = 0.001728
Prover Time taken = 0.001449
Prover Time taken = 0.001502
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 1 < turn + flag2)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001542
Prover Time taken = 0.003913
Added Horn clause: 146 => 147
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0208950
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < flag1 + flag2 && 0 < x + turn)
}
Prover Time taken = 0.001984
Prover Time taken = 0.002
Prover Time taken = 0.001346
Prover Time taken = 0.001364
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < flag1 + flag2 && 0 < x + turn)
}
Prover Time taken = 0.001377
Prover Time taken = 0.001329
Prover Time taken = 0.001282
Prover Time taken = 0.001345
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && 0 < flag1 + flag2 && 0 < x + turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001773
Prover Time taken = 0.003154
Added Horn clause: 148 && 149 => 150
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0273520
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && x - flag1 <= 1 && 1 < turn + flag2)
}
Prover Time taken = 0.001518
Prover Time taken = 0.00109
Prover Time taken = 0.001376
Prover Time taken = 0.001326
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && x - flag1 <= 1 && 1 < turn + flag2)
}
Prover Time taken = 0.001338
Prover Time taken = 0.001451
Prover Time taken = 0.001347
Prover Time taken = 0.001281
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && x - flag1 <= 1 && 1 < turn + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001719
Prover Time taken = 0.003141
Added Horn clause: 151 && 152 => 153
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0219410
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && x <= -1 && 0 < x + turn)
}
Prover Time taken = 0.001202
Prover Time taken = 0.001491
Prover Time taken = 0.001311
Prover Time taken = 0.00156
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && x <= -1 && 0 < x + turn)
}
Prover Time taken = 0.001763
Prover Time taken = 0.001539
Prover Time taken = 0.001503
Prover Time taken = 0.001717
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && x <= -1 && 0 < x + turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001721
Prover Time taken = 0.001983
Prover Time taken = 0.001631
Prover Time taken = 0.001701
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && x <= -1 && 0 < x + turn)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001472
Prover Time taken = 0.001102
Prover Time taken = 0.001725
Prover Time taken = 0.001557
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && x <= -1 && 0 < x + turn)
}
Prover Time taken = 0.001081
Prover Time taken = 0.001477
Prover Time taken = 0.001188
Prover Time taken = 0.000922
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 0 && -1 < flag2) || (x + flag2 <= -1 && 0 < turn && x <= -1 && 0 < x + turn)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003706
Added Horn clause: 154 && 155 => 156
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0195800
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + turn <= 1 && -1 < flag2 && 0 < turn + flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.001134
Prover Time taken = 0.001011
Prover Time taken = 0.001288
Prover Time taken = 0.000919
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + turn <= 1 && -1 < flag2 && 0 < turn + flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.001457
Prover Time taken = 0.001242
Prover Time taken = 0.001149
Prover Time taken = 0.001686
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + turn <= 1 && -1 < flag2 && 0 < turn + flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.0019
Prover Time taken = 0.001915
Prover Time taken = 0.001815
Prover Time taken = 0.002166
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + turn <= 1 && -1 < flag2 && 0 < turn + flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.003266
Added Horn clause: 157 => 144
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0279590
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn + flag1 <= 0) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn + flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.001899
Prover Time taken = 0.001572
Prover Time taken = 0.001555
Prover Time taken = 0.001644
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn + flag1 <= 0) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn + flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.00156
Prover Time taken = 0.001623
Prover Time taken = 0.001145
Prover Time taken = 0.001179
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn + flag1 <= 0) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn + flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002032
Prover Time taken = 0.002224
Prover Time taken = 0.002339
Prover Time taken = 0.00206
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn + flag1 <= 0) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn + flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.004262
Added Horn clause: 158 => 139
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0210300
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn - flag1 <= 0 && turn <= 0 && x - flag1 <= -1) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn - flag1)
}
Prover Time taken = 0.001678
Prover Time taken = 0.001213
Prover Time taken = 0.001279
Prover Time taken = 0.001098
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn - flag1 <= 0 && turn <= 0 && x - flag1 <= -1) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn - flag1)
}
Prover Time taken = 0.00151
Prover Time taken = 0.001615
Prover Time taken = 0.001484
Prover Time taken = 0.001904
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn - flag1 <= 0 && turn <= 0 && x - flag1 <= -1) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.007131
Added Horn clause: 156 && 159 => 160
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0228280
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn - flag1 <= 0 && turn <= 0 && x - turn <= 1) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn - flag1)
}
Prover Time taken = 0.001596
Prover Time taken = 0.00145
Prover Time taken = 0.001094
Prover Time taken = 0.00145
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn - flag1 <= 0 && turn <= 0 && x - turn <= 1) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn - flag1)
}
Prover Time taken = 0.001777
Prover Time taken = 0.002047
Prover Time taken = 0.001256
Prover Time taken = 0.001736
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn - flag1 <= 0 && turn <= 0 && x - turn <= 1) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.003389
Added Horn clause: 161 && 162 => 163
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0259880
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 1 && turn <= 0 && -1 < turn) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 1 < turn)
}
Prover Time taken = 0.001313
Prover Time taken = 0.00108
Prover Time taken = 0.001062
Prover Time taken = 0.001074
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 1 && turn <= 0 && -1 < turn) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 1 < turn)
}
Prover Time taken = 0.001281
Prover Time taken = 0.001298
Prover Time taken = 0.001171
Prover Time taken = 0.001264
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 1 && turn <= 0 && -1 < turn) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 1 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.00194
Prover Time taken = 0.0014
Prover Time taken = 0.0013
Prover Time taken = 0.001552
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 1 && turn <= 0 && -1 < turn) || (x + turn <= 1 && -1 < flag2 && flag2 <= 0 && 1 < turn)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.003455
Added Horn clause: 156 => 77
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0199590
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn + flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 0 < turn + flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.001448
Prover Time taken = 0.000935
Prover Time taken = 0.001659
Prover Time taken = 0.000925
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn + flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 0 < turn + flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.001371
Prover Time taken = 0.001575
Prover Time taken = 0.001221
Prover Time taken = 0.001334
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn + flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 0 < turn + flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001831
Prover Time taken = 0.001431
Prover Time taken = 0.001455
Prover Time taken = 0.002082
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn + flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 0 < turn + flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002908
Added Horn clause: 164 => 139
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0264270
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn <= 1 && turn <= 0 && flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 1 < turn)
}
Prover Time taken = 0.001429
Prover Time taken = 0.001246
Prover Time taken = 0.001529
Prover Time taken = 0.003346
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn <= 1 && turn <= 0 && flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 1 < turn)
}
Prover Time taken = 0.002076
Prover Time taken = 0.00123
Prover Time taken = 0.001315
Prover Time taken = 0.001312
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn <= 1 && turn <= 0 && flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 1 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001564
Prover Time taken = 0.00137
Prover Time taken = 0.001512
Prover Time taken = 0.001642
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn <= 1 && turn <= 0 && flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 1 < turn)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001651
Prover Time taken = 0.001736
Prover Time taken = 0.001572
Prover Time taken = 0.00143
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn <= 1 && turn <= 0 && flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 1 < turn)
}
Prover Time taken = 0.002989
Prover Time taken = 0.001569
Prover Time taken = 0.001183
Prover Time taken = 0.001022
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + turn <= 1 && x - turn <= -1 && turn <= 1 && turn <= 0 && flag1 <= 0) || (x + turn <= 1 && x - turn <= -1 && 1 < turn)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003592
Added Horn clause: 165 && 166 => 167
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0209560
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && -1 < turn) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.001145
Prover Time taken = 0.000942
Prover Time taken = 0.000941
Prover Time taken = 0.00098
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && -1 < turn) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.001456
Prover Time taken = 0.001095
Prover Time taken = 0.001131
Prover Time taken = 0.001229
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && -1 < turn) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001346
Prover Time taken = 0.001312
Prover Time taken = 0.001673
Prover Time taken = 0.001239
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && -1 < turn) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002595
Added Horn clause: 168 => 139
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0259470
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && -1 < flag1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.002313
Prover Time taken = 0.001166
Prover Time taken = 0.000903
Prover Time taken = 0.000935
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && -1 < flag1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.001923
Prover Time taken = 0.001677
Prover Time taken = 0.001477
Prover Time taken = 0.0014
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && -1 < flag1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001725
Prover Time taken = 0.00134
Prover Time taken = 0.002693
Prover Time taken = 0.001449
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && -1 < flag1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002886
Added Horn clause: 169 => 44
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0241850
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag2 <= -1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.001225
Prover Time taken = 0.000916
Prover Time taken = 0.000922
Prover Time taken = 0.001263
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag2 <= -1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.001538
Prover Time taken = 0.001373
Prover Time taken = 0.001383
Prover Time taken = 0.001344
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag2 <= -1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001638
Prover Time taken = 0.001333
Prover Time taken = 0.001363
Prover Time taken = 0.001321
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag2 <= -1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002611
Added Horn clause: 170 => 40
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0220090
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
Prover Time taken = 0.001207
Prover Time taken = 0.001307
Prover Time taken = 0.000919
Prover Time taken = 0.000866
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
Prover Time taken = 0.001434
Prover Time taken = 0.001252
Prover Time taken = 0.001559
Prover Time taken = 0.001138
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001451
Prover Time taken = 0.001505
Prover Time taken = 0.00151
Prover Time taken = 0.003157
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001454
Prover Time taken = 0.001369
Prover Time taken = 0.00126
Prover Time taken = 0.001088
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
Prover Time taken = 0.002034
Prover Time taken = 0.001762
Prover Time taken = 0.001598
Prover Time taken = 0.001213
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn + flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003378
Added Horn clause: 171 && 172 => 173
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0228990
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
Prover Time taken = 0.001121
Prover Time taken = 0.000912
Prover Time taken = 0.001191
Prover Time taken = 0.001181
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
Prover Time taken = 0.001358
Prover Time taken = 0.001252
Prover Time taken = 0.001064
Prover Time taken = 0.001096
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001535
Prover Time taken = 0.001542
Prover Time taken = 0.00136
Prover Time taken = 0.001338
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001623
Prover Time taken = 0.001526
Prover Time taken = 0.001046
Prover Time taken = 0.001163
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
Prover Time taken = 0.001824
Prover Time taken = 0.001375
Prover Time taken = 0.001619
Prover Time taken = 0.001209
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00405
Added Horn clause: 174 && 175 => 176
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0242850
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && 1 < turn + flag2)
}
Prover Time taken = 0.001911
Prover Time taken = 0.001461
Prover Time taken = 0.001505
Prover Time taken = 0.001423
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && 1 < turn + flag2)
}
Prover Time taken = 0.001888
Prover Time taken = 0.001153
Prover Time taken = 0.001268
Prover Time taken = 0.001472
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && 1 < turn + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002084
Prover Time taken = 0.001645
Prover Time taken = 0.001494
Prover Time taken = 0.001489
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && 1 < turn + flag2)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002935
Added Horn clause: 177 => 39
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0214360
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && x + flag1 <= 0 && 0 < x + turn)
}
Prover Time taken = 0.001118
Prover Time taken = 0.001432
Prover Time taken = 0.001223
Prover Time taken = 0.001023
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && x + flag1 <= 0 && 0 < x + turn)
}
Prover Time taken = 0.001263
Prover Time taken = 0.001174
Prover Time taken = 0.001253
Prover Time taken = 0.001188
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && x + flag1 <= 0 && 0 < x + turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002265
Prover Time taken = 0.002213
Prover Time taken = 0.001829
Prover Time taken = 0.001853
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && x + flag1 <= 0 && 0 < x + turn)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001473
Prover Time taken = 0.001638
Prover Time taken = 0.001366
Prover Time taken = 0.001341
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && x + flag1 <= 0 && 0 < x + turn)
}
Prover Time taken = 0.001146
Prover Time taken = 0.001028
Prover Time taken = 0.000979
Prover Time taken = 0.001341
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag1 <= -1 && flag1 <= 1 && flag1 <= 0) || (x - flag1 <= -1 && flag1 <= 1 && 0 < flag1 && x + flag1 <= 0 && 0 < x + turn)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.004381
Added Horn clause: 178 && 179 => 180
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0285700
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
Prover Time taken = 0.001631
Prover Time taken = 0.001386
Prover Time taken = 0.000959
Prover Time taken = 0.001103
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
Prover Time taken = 0.001661
Prover Time taken = 0.001557
Prover Time taken = 0.00172
Prover Time taken = 0.001365
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.00156
Prover Time taken = 0.001973
Prover Time taken = 0.00222
Prover Time taken = 0.001832
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001732
Prover Time taken = 0.001748
Prover Time taken = 0.001685
Prover Time taken = 0.001655
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
Prover Time taken = 0.00135
Prover Time taken = 0.001308
Prover Time taken = 0.001038
Prover Time taken = 0.001164
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag2 <= -1 && turn <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (x + flag2 <= -1 && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.004407
Added Horn clause: 181 && 182 => 183
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0355860
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 + flag2 <= 0 && -1 < turn + flag2) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.00136
Prover Time taken = 0.001203
Prover Time taken = 0.001236
Prover Time taken = 0.001577
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 + flag2 <= 0 && -1 < turn + flag2) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.001667
Prover Time taken = 0.001645
Prover Time taken = 0.001698
Prover Time taken = 0.00136
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 + flag2 <= 0 && -1 < turn + flag2) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.004871
Added Horn clause: 184 && 185 => 186
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0254710
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.001329
Prover Time taken = 0.001907
Prover Time taken = 0.001583
Prover Time taken = 0.00124
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
Prover Time taken = 0.001568
Prover Time taken = 0.001572
Prover Time taken = 0.001902
Prover Time taken = 0.001536
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002183
Prover Time taken = 0.002075
Prover Time taken = 0.001422
Prover Time taken = 0.001766
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x - flag2 <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.003832
Added Horn clause: 187 => 139
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0261160
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && turn - flag2 <= 0)
}
Prover Time taken = 0.001193
Prover Time taken = 0.001294
Prover Time taken = 0.001055
Prover Time taken = 0.001206
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && turn - flag2 <= 0)
}
Prover Time taken = 0.001507
Prover Time taken = 0.001192
Prover Time taken = 0.001206
Prover Time taken = 0.001297
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && turn - flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002117
Prover Time taken = 0.001931
Prover Time taken = 0.001992
Prover Time taken = 0.002127
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002655
Added Horn clause: 188 => 131
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0335710
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x)
}
Prover Time taken = 0.001317
Prover Time taken = 0.001048
Prover Time taken = 0.001025
Prover Time taken = 0.001102
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x)
}
Prover Time taken = 0.001472
Prover Time taken = 0.001256
Prover Time taken = 0.001156
Prover Time taken = 0.001612
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001663
Prover Time taken = 0.001811
Prover Time taken = 0.001659
Prover Time taken = 0.001598
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.003179
Added Horn clause: 189 => 190
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0327930
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && turn + flag1 <= 0)
}
Prover Time taken = 0.001445
Prover Time taken = 0.003291
Prover Time taken = 0.00142
Prover Time taken = 0.0015
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && turn + flag1 <= 0)
}
Prover Time taken = 0.001697
Prover Time taken = 0.00163
Prover Time taken = 0.001626
Prover Time taken = 0.001646
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && turn + flag1 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.003664
Added Horn clause: 167 && 191 => 192
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0276910
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && turn + flag1 <= 0) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && 0 < turn + flag1 && 0 < x + flag1)
}
Prover Time taken = 0.001327
Prover Time taken = 0.001195
Prover Time taken = 0.001335
Prover Time taken = 0.001216
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && turn + flag1 <= 0) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && 0 < turn + flag1 && 0 < x + flag1)
}
Prover Time taken = 0.002208
Prover Time taken = 0.001854
Prover Time taken = 0.00136
Prover Time taken = 0.001622
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && turn + flag1 <= 0) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && 0 < turn + flag1 && 0 < x + flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002305
Prover Time taken = 0.002792
Prover Time taken = 0.002056
Prover Time taken = 0.002653
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && turn + flag1 <= 0) || (0 < turn && 1 < turn && -1 < x && x - flag2 <= -1 && 0 < x && 0 < turn + flag1 && 0 < x + flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.003056
Added Horn clause: 167 => 193
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0332390
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001179
Prover Time taken = 0.001101
Prover Time taken = 0.001471
Prover Time taken = 0.001106
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001199
Prover Time taken = 0.001539
Prover Time taken = 0.00108
Prover Time taken = 0.001128
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.00139
Prover Time taken = 0.001489
Prover Time taken = 0.001791
Prover Time taken = 0.00132
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001416
Prover Time taken = 0.001587
Prover Time taken = 0.001207
Prover Time taken = 0.000954
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001191
Prover Time taken = 0.000937
Prover Time taken = 0.001152
Prover Time taken = 0.00093
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003499
Added Horn clause: 194 && 195 => 170
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0258940
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && x - flag1 <= -1 && turn + flag1 <= 0) || (flag2 <= 0 && -1 < flag2 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < turn - flag1 && x + flag1 <= 0)
}
Prover Time taken = 0.001682
Prover Time taken = 0.001682
Prover Time taken = 0.000923
Prover Time taken = 0.001404
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && x - flag1 <= -1 && turn + flag1 <= 0) || (flag2 <= 0 && -1 < flag2 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < turn - flag1 && x + flag1 <= 0)
}
Prover Time taken = 0.001572
Prover Time taken = 0.001376
Prover Time taken = 0.001703
Prover Time taken = 0.001748
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && x - flag1 <= -1 && turn + flag1 <= 0) || (flag2 <= 0 && -1 < flag2 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < turn - flag1 && x + flag1 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.003766
Added Horn clause: 196 && 197 => 198
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0312090
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && x + flag1 <= 0 && turn - flag1 <= 0 && turn + flag1 <= 0 && x - turn <= -1) || (flag2 <= 0 && -1 < flag2 && x + flag1 <= 0 && 0 < turn - flag1 && -1 < turn + flag1)
}
Prover Time taken = 0.001392
Prover Time taken = 0.001029
Prover Time taken = 0.001008
Prover Time taken = 0.001019
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && x + flag1 <= 0 && turn - flag1 <= 0 && turn + flag1 <= 0 && x - turn <= -1) || (flag2 <= 0 && -1 < flag2 && x + flag1 <= 0 && 0 < turn - flag1 && -1 < turn + flag1)
}
Prover Time taken = 0.002101
Prover Time taken = 0.002019
Prover Time taken = 0.001511
Prover Time taken = 0.00156
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && x + flag1 <= 0 && turn - flag1 <= 0 && turn + flag1 <= 0 && x - turn <= -1) || (flag2 <= 0 && -1 < flag2 && x + flag1 <= 0 && 0 < turn - flag1 && -1 < turn + flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.003954
Added Horn clause: 199 && 200 => 37
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0251140
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && turn <= 0 && flag1 <= 0 && -1 < turn) || (flag2 <= 0 && -1 < flag2 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.00119
Prover Time taken = 0.000962
Prover Time taken = 0.001017
Prover Time taken = 0.00098
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && turn <= 0 && flag1 <= 0 && -1 < turn) || (flag2 <= 0 && -1 < flag2 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.001227
Prover Time taken = 0.00108
Prover Time taken = 0.00177
Prover Time taken = 0.001501
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && turn <= 0 && flag1 <= 0 && -1 < turn) || (flag2 <= 0 && -1 < flag2 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001426
Prover Time taken = 0.001373
Prover Time taken = 0.001302
Prover Time taken = 0.001321
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && -1 < flag2 && turn <= 0 && flag1 <= 0 && -1 < turn) || (flag2 <= 0 && -1 < flag2 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002603
Added Horn clause: 201 => 83
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0255240
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && turn + flag1 <= 0) || (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < x + turn)
}
Prover Time taken = 0.001422
Prover Time taken = 0.001064
Prover Time taken = 0.000956
Prover Time taken = 0.001106
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && turn + flag1 <= 0) || (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < x + turn)
}
Prover Time taken = 0.002027
Prover Time taken = 0.002394
Prover Time taken = 0.001767
Prover Time taken = 0.001893
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && turn + flag1 <= 0) || (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < x + turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002581
Prover Time taken = 0.002301
Prover Time taken = 0.002081
Prover Time taken = 0.002893
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && turn + flag1 <= 0) || (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < x + turn)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002145
Prover Time taken = 0.002389
Prover Time taken = 0.001792
Prover Time taken = 0.001834
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && turn + flag1 <= 0) || (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < x + turn)
}
Prover Time taken = 0.001204
Prover Time taken = 0.001093
Prover Time taken = 0.001347
Prover Time taken = 0.001536
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && turn + flag1 <= 0) || (flag2 <= 0 && x <= 1 && -1 < flag2 && x + flag1 <= 0 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < x + turn)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.005508
Added Horn clause: 202 && 203 => 198
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0318220
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (flag2 <= 0 && x <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && -1 < x - flag1 && 0 < x) || (flag2 <= 0 && x <= 1 && -1 < flag2 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.001755
Prover Time taken = 0.002874
Prover Time taken = 0.001177
Prover Time taken = 0.001286
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (flag2 <= 0 && x <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && -1 < x - flag1 && 0 < x) || (flag2 <= 0 && x <= 1 && -1 < flag2 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.001328
Prover Time taken = 0.001246
Prover Time taken = 0.001544
Prover Time taken = 0.001403
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (flag2 <= 0 && x <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && -1 < x - flag1 && 0 < x) || (flag2 <= 0 && x <= 1 && -1 < flag2 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001811
Prover Time taken = 0.001812
Prover Time taken = 0.002363
Prover Time taken = 0.001966
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 0 && x <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (flag2 <= 0 && x <= 1 && -1 < flag2 && turn <= 0 && flag1 <= 0 && -1 < x - flag1 && 0 < x) || (flag2 <= 0 && x <= 1 && -1 < flag2 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002757
Added Horn clause: 198 => 40
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0321890
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001565
Prover Time taken = 0.00119
Prover Time taken = 0.001523
Prover Time taken = 0.001363
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001375
Prover Time taken = 0.00157
Prover Time taken = 0.002053
Prover Time taken = 0.001773
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.00232
Prover Time taken = 0.001776
Prover Time taken = 0.00136
Prover Time taken = 0.001988
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001152
Prover Time taken = 0.001094
Prover Time taken = 0.00124
Prover Time taken = 0.001575
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001559
Prover Time taken = 0.002621
Prover Time taken = 0.001086
Prover Time taken = 0.000943
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003029
Added Horn clause: 204 && 205 => 186
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0263850
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag2 <= 1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001139
Prover Time taken = 0.001018
Prover Time taken = 0.000933
Prover Time taken = 0.000842
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag2 <= 1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.00144
Prover Time taken = 0.00113
Prover Time taken = 0.001216
Prover Time taken = 0.001251
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag2 <= 1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001375
Prover Time taken = 0.001433
Prover Time taken = 0.00144
Prover Time taken = 0.001294
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag2 <= 1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002836
Added Horn clause: 206 => 44
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0302420
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag2 <= -1) || (-1 < turn && turn <= 0 && flag1 <= 0 && -1 < x - flag2 && 0 < x && x <= 1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001178
Prover Time taken = 0.001017
Prover Time taken = 0.001424
Prover Time taken = 0.001408
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag2 <= -1) || (-1 < turn && turn <= 0 && flag1 <= 0 && -1 < x - flag2 && 0 < x && x <= 1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001638
Prover Time taken = 0.001423
Prover Time taken = 0.001192
Prover Time taken = 0.001333
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag2 <= -1) || (-1 < turn && turn <= 0 && flag1 <= 0 && -1 < x - flag2 && 0 < x && x <= 1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001655
Prover Time taken = 0.001628
Prover Time taken = 0.001887
Prover Time taken = 0.001621
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn && turn <= 0 && flag1 <= 0 && x - flag2 <= -1) || (-1 < turn && turn <= 0 && flag1 <= 0 && -1 < x - flag2 && 0 < x && x <= 1) || (-1 < turn && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.00327
Added Horn clause: 186 => 40
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0269910
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && turn + flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < turn - flag1 && x + flag1 <= 0)
}
Prover Time taken = 0.001257
Prover Time taken = 0.00111
Prover Time taken = 0.001565
Prover Time taken = 0.001106
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && turn + flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < turn - flag1 && x + flag1 <= 0)
}
Prover Time taken = 0.00162
Prover Time taken = 0.001887
Prover Time taken = 0.001449
Prover Time taken = 0.001484
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && turn + flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < turn - flag1 && x + flag1 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002975
Prover Time taken = 0.002464
Prover Time taken = 0.002227
Prover Time taken = 0.00176
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && turn + flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < turn - flag1 && x + flag1 <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.002668
Prover Time taken = 0.001328
Prover Time taken = 0.001362
Prover Time taken = 0.002028
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && turn + flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < turn - flag1 && x + flag1 <= 0)
}
Prover Time taken = 0.001477
Prover Time taken = 0.001343
Prover Time taken = 0.001435
Prover Time taken = 0.00108
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && turn + flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && x - flag1 <= -1 && 0 < turn + flag1 && 0 < turn - flag1 && x + flag1 <= 0)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.004761
Added Horn clause: 207 && 208 => 209
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0343160
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && x + flag1 <= 0 && turn <= 0 && flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && x + flag1 <= 0 && 0 < turn && 1 < turn && 0 < turn + flag1)
}
Prover Time taken = 0.001296
Prover Time taken = 0.001119
Prover Time taken = 0.001011
Prover Time taken = 0.001105
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && x + flag1 <= 0 && turn <= 0 && flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && x + flag1 <= 0 && 0 < turn && 1 < turn && 0 < turn + flag1)
}
Prover Time taken = 0.00136
Prover Time taken = 0.001273
Prover Time taken = 0.001371
Prover Time taken = 0.001911
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && x + flag1 <= 0 && turn <= 0 && flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && x + flag1 <= 0 && 0 < turn && 1 < turn && 0 < turn + flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.004235
Added Horn clause: 176 && 210 => 160
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0283520
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.001266
Prover Time taken = 0.00112
Prover Time taken = 0.001049
Prover Time taken = 0.001061
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.001335
Prover Time taken = 0.001366
Prover Time taken = 0.001443
Prover Time taken = 0.001783
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001611
Prover Time taken = 0.00218
Prover Time taken = 0.003334
Prover Time taken = 0.001604
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.003994
Added Horn clause: 211 => 139
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0289250
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.001384
Prover Time taken = 0.001085
Prover Time taken = 0.001034
Prover Time taken = 0.001215
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.001314
Prover Time taken = 0.001708
Prover Time taken = 0.001181
Prover Time taken = 0.001306
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001634
Prover Time taken = 0.00152
Prover Time taken = 0.001603
Prover Time taken = 0.001505
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.00336
Added Horn clause: 212 => 44
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0290620
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.001247
Prover Time taken = 0.001379
Prover Time taken = 0.001042
Prover Time taken = 0.001019
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.00278
Prover Time taken = 0.00125
Prover Time taken = 0.001474
Prover Time taken = 0.001333
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001849
Prover Time taken = 0.002107
Prover Time taken = 0.001481
Prover Time taken = 0.001937
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.001509
Prover Time taken = 0.001379
Prover Time taken = 0.001127
Prover Time taken = 0.001192
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
Prover Time taken = 0.001378
Prover Time taken = 0.001302
Prover Time taken = 0.001391
Prover Time taken = 0.001372
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && turn <= 0 && flag1 <= 0 && x - flag1 <= -1) || (-1 < turn - flag2 && x <= 1 && -1 < flag2 && flag2 <= 0 && 0 < turn && 1 < turn && x <= -1)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.004477
Added Horn clause: 213 && 214 => 160
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0293120
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && turn <= 0 && flag1 - flag2 <= 0 && turn - flag1 <= 0 && x + turn <= -1) || (-1 < turn - flag2 && x <= 1 && turn <= 0 && flag1 - flag2 <= 0 && turn - flag1 <= 0 && -1 < x + turn && 0 < x) || (-1 < turn - flag2 && x <= 1 && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.00143
Prover Time taken = 0.001579
Prover Time taken = 0.0014
Prover Time taken = 0.001504
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && turn <= 0 && flag1 - flag2 <= 0 && turn - flag1 <= 0 && x + turn <= -1) || (-1 < turn - flag2 && x <= 1 && turn <= 0 && flag1 - flag2 <= 0 && turn - flag1 <= 0 && -1 < x + turn && 0 < x) || (-1 < turn - flag2 && x <= 1 && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001605
Prover Time taken = 0.001395
Prover Time taken = 0.001377
Prover Time taken = 0.002025
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && turn <= 0 && flag1 - flag2 <= 0 && turn - flag1 <= 0 && x + turn <= -1) || (-1 < turn - flag2 && x <= 1 && turn <= 0 && flag1 - flag2 <= 0 && turn - flag1 <= 0 && -1 < x + turn && 0 < x) || (-1 < turn - flag2 && x <= 1 && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.004402
Added Horn clause: 134 && 215 => 216
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0307490
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && turn <= 0 && turn - flag2 <= 0 && flag1 <= 0 && turn - flag1 <= 0 && x + turn <= -1) || (-1 < turn - flag2 && x <= 1 && turn <= 0 && turn - flag2 <= 0 && flag1 <= 0 && turn - flag1 <= 0 && -1 < x + turn && 0 < x) || (-1 < turn - flag2 && x <= 1 && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001797
Prover Time taken = 0.001772
Prover Time taken = 0.001281
Prover Time taken = 0.001328
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && turn <= 0 && turn - flag2 <= 0 && flag1 <= 0 && turn - flag1 <= 0 && x + turn <= -1) || (-1 < turn - flag2 && x <= 1 && turn <= 0 && turn - flag2 <= 0 && flag1 <= 0 && turn - flag1 <= 0 && -1 < x + turn && 0 < x) || (-1 < turn - flag2 && x <= 1 && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
Prover Time taken = 0.001609
Prover Time taken = 0.001671
Prover Time taken = 0.002051
Prover Time taken = 0.001839
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && turn <= 0 && turn - flag2 <= 0 && flag1 <= 0 && turn - flag1 <= 0 && x + turn <= -1) || (-1 < turn - flag2 && x <= 1 && turn <= 0 && turn - flag2 <= 0 && flag1 <= 0 && turn - flag1 <= 0 && -1 < x + turn && 0 < x) || (-1 < turn - flag2 && x <= 1 && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.002054
Prover Time taken = 0.002087
Prover Time taken = 0.002458
Prover Time taken = 0.005881
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && x <= 1 && turn <= 0 && turn - flag2 <= 0 && flag1 <= 0 && turn - flag1 <= 0 && x + turn <= -1) || (-1 < turn - flag2 && x <= 1 && turn <= 0 && turn - flag2 <= 0 && flag1 <= 0 && turn - flag1 <= 0 && -1 < x + turn && 0 < x) || (-1 < turn - flag2 && x <= 1 && 0 < turn && 1 < turn && x <= -1 && flag2 <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.003376
Added Horn clause: 216 => 40
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0278330
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0 && x <= -1) || (-1 < turn - flag2 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0 && -1 < x && 0 < x && x <= 1) || (-1 < turn - flag2 && -1 < flag2 && 0 < turn && 1 < turn - flag2 && x <= -1)
}
Prover Time taken = 0.00144
Prover Time taken = 0.001309
Prover Time taken = 0.001431
Prover Time taken = 0.003327
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0 && x <= -1) || (-1 < turn - flag2 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0 && -1 < x && 0 < x && x <= 1) || (-1 < turn - flag2 && -1 < flag2 && 0 < turn && 1 < turn - flag2 && x <= -1)
}
Prover Time taken = 0.001603
Prover Time taken = 0.001357
Prover Time taken = 0.001366
Prover Time taken = 0.001344
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0 && x <= -1) || (-1 < turn - flag2 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0 && -1 < x && 0 < x && x <= 1) || (-1 < turn - flag2 && -1 < flag2 && 0 < turn && 1 < turn - flag2 && x <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x
}
Prover Time taken = 0.001858
Prover Time taken = 0.001693
Prover Time taken = 0.001925
Prover Time taken = 0.001812
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (-1 < turn - flag2 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0 && x <= -1) || (-1 < turn - flag2 && -1 < flag2 && turn <= 0 && flag1 <= 0 && turn - flag1 <= 0 && -1 < x && 0 < x && x <= 1) || (-1 < turn - flag2 && -1 < flag2 && 0 < turn && 1 < turn - flag2 && x <= -1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1
}
Prover Time taken = 0.003397
Added Horn clause: 160 => 40
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0242710
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 0 || (0 < flag2 && x <= 0 && -1 < x + flag2)
}
Prover Time taken = 0.001153
Prover Time taken = 0.001002
Prover Time taken = 0.001008
Prover Time taken = 0.00098
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag2 && 0 < flag1 && turn - flag2 <= 0)
}
Prover Time taken = 0.001135
Prover Time taken = 0.001133
Prover Time taken = 0.001075
Prover Time taken = 0.001122
Verifying P3_stable_t2_s1: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000871
Prover Time taken = 0.000763
Prover Time taken = 0.000761
Prover Time taken = 0.000871
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001174
Prover Time taken = 0.001035
Prover Time taken = 0.000974
Prover Time taken = 0.001298
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag2 && 0 < flag1 && turn - flag2 <= 0)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000918
Prover Time taken = 0.000795
Prover Time taken = 0.000808
Prover Time taken = 0.000861
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag2 && 0 < flag1 && turn - flag2 <= 0)
}
Prover Time taken = 0.000994
Prover Time taken = 0.001229
Prover Time taken = 0.001262
Prover Time taken = 0.002799
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 0 || (0 < flag2 && x <= 0 && -1 < x + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag2 && 0 < flag1 && turn - flag2 <= 0)
}
Prover Time taken = 0.00269
Added Horn clause: 217 => 218
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0291550
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 0 || (0 < flag2 && x <= 0)
}
Prover Time taken = 0.001297
Prover Time taken = 0.00112
Prover Time taken = 0.000818
Prover Time taken = 0.001388
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && turn - flag2 <= 1 && flag1 + flag2 <= -1 && -1 < turn - flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && -1 < flag2 && 1 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.001615
Prover Time taken = 0.001561
Prover Time taken = 0.001567
Prover Time taken = 0.001527
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && turn - flag2 <= 1 && flag1 + flag2 <= -1 && -1 < turn - flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && -1 < flag2 && 1 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001524
Prover Time taken = 0.00148
Prover Time taken = 0.001337
Prover Time taken = 0.001936
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && turn - flag2 <= 1 && flag1 + flag2 <= -1 && -1 < turn - flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && -1 < flag2 && 1 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
Added: P2:0,2,-2,0: negative
Prover Time taken = 0.003588
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0296390
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && flag2 <= 1 && 0 < flag2 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.002084
Prover Time taken = 0.003612
Prover Time taken = 0.001515
Prover Time taken = 0.00162
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && flag2 <= 1 && 0 < flag2 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001637
Prover Time taken = 0.001461
Prover Time taken = 0.001469
Prover Time taken = 0.002207
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && flag2 <= 1 && 0 < flag2 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
Added: P2:0,-2,-2,2: negative
Prover Time taken = 0.003352
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0291990
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && flag1 + flag2 <= -1 && flag2 <= 1 && 0 < flag2 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && -1 < flag2 && flag1 + flag2 <= -1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.00231
Prover Time taken = 0.002053
Prover Time taken = 0.001766
Prover Time taken = 0.002118
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && flag1 + flag2 <= -1 && flag2 <= 1 && 0 < flag2 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && -1 < flag2 && flag1 + flag2 <= -1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001908
Prover Time taken = 0.001998
Prover Time taken = 0.001969
Prover Time taken = 0.001747
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && flag1 + flag2 <= -1 && flag2 <= 1 && 0 < flag2 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && -1 < flag2 && flag1 + flag2 <= -1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.002069
Added: P2:-5,-5,-5,2: negative
Prover Time taken = 0.003191
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0283520
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && x - turn <= 0 && 0 < x && x <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.001562
Prover Time taken = 0.002116
Prover Time taken = 0.00128
Prover Time taken = 0.001654
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && x - turn <= 0 && 0 < x && x <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001805
Prover Time taken = 0.001731
Prover Time taken = 0.00127
Prover Time taken = 0.00143
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && x - turn <= 0 && 0 < x && x <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.001722
Added: P2:0,5,2,5: negative
Prover Time taken = 0.003363
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0296590
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && x - turn <= 0 && 0 < x && x <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001601
Prover Time taken = 0.001802
Prover Time taken = 0.001976
Prover Time taken = 0.001772
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && x - turn <= 0 && 0 < x && x <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001929
Prover Time taken = 0.001301
Prover Time taken = 0.001342
Prover Time taken = 0.001437
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && x - turn <= 0 && 0 < x && x <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.00187
Prover Time taken = 0.002084
Prover Time taken = 0.00376
Prover Time taken = 0.001743
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 0 || (0 < flag2 && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag2 <= -1 && 0 < x && x + flag2 <= -1) || (x + flag1 <= 1 && -1 < flag2 && 1 < x - flag1 && x - turn <= 0 && 0 < x && x <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.003495
Added Horn clause: 223 => 224
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0309100
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 0)
}
Prover Time taken = 0.001008
Prover Time taken = 0.000933
Prover Time taken = 0.00095
Prover Time taken = 0.000707
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && x + flag1 <= 0 && 0 < flag2 && flag2 <= 1 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && x + flag1 <= 0 && 0 < flag2 && 1 < flag2 && 0 < x - flag1) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x + flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001657
Prover Time taken = 0.001644
Prover Time taken = 0.001636
Prover Time taken = 0.001726
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && x + flag1 <= 0 && 0 < flag2 && flag2 <= 1 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && x + flag1 <= 0 && 0 < flag2 && 1 < flag2 && 0 < x - flag1) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x + flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002191
Prover Time taken = 0.002788
Prover Time taken = 0.002984
Prover Time taken = 0.001921
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && x + flag1 <= 0 && 0 < flag2 && flag2 <= 1 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && x + flag1 <= 0 && 0 < flag2 && 1 < flag2 && 0 < x - flag1) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x + flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Added: P2:0,-2,1,-2: negative
Prover Time taken = 0.003915
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0291070
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x - flag1 && flag1 <= -1 && flag2 <= 1 && 0 < flag2 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x - flag1 && flag1 <= -1 && 1 < flag2) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x - flag1 && -1 < flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001676
Prover Time taken = 0.001534
Prover Time taken = 0.001697
Prover Time taken = 0.001664
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x - flag1 && flag1 <= -1 && flag2 <= 1 && 0 < flag2 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x - flag1 && flag1 <= -1 && 1 < flag2) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x - flag1 && -1 < flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001648
Prover Time taken = 0.001553
Prover Time taken = 0.001599
Prover Time taken = 0.001527
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x - flag1 && flag1 <= -1 && flag2 <= 1 && 0 < flag2 && -1 < turn + flag2 && x - flag2 <= 0 && 0 < x) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x - flag1 && flag1 <= -1 && 1 < flag2) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x - flag1 && -1 < flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002702
Added: P2:0,-5,-3,2: negative
Prover Time taken = 0.004273
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0299460
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x && x <= 1 && turn + flag1 <= 0 && x + turn <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x && x <= 1 && turn + flag1 <= 0 && -1 < x + turn) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002035
Prover Time taken = 0.001829
Prover Time taken = 0.001978
Prover Time taken = 0.001848
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x && x <= 1 && turn + flag1 <= 0 && x + turn <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x && x <= 1 && turn + flag1 <= 0 && -1 < x + turn) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002027
Prover Time taken = 0.001464
Prover Time taken = 0.001304
Prover Time taken = 0.001699
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x && x <= 1 && turn + flag1 <= 0 && x + turn <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x && x <= 1 && turn + flag1 <= 0 && -1 < x + turn) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002305
Prover Time taken = 0.002105
Prover Time taken = 0.003338
Prover Time taken = 0.001939
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x && x <= 1 && turn + flag1 <= 0 && x + turn <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && flag1 + flag2 <= -1 && 0 < x && x <= 1 && turn + flag1 <= 0 && -1 < x + turn) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.004763
Added Horn clause: 195 => 227
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0307560
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && flag2 <= 1 && x <= 1 && turn + flag1 <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && flag2 <= 1 && x <= 1 && turn + flag1 <= -1 && 0 < x + flag2 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001837
Prover Time taken = 0.002009
Prover Time taken = 0.001838
Prover Time taken = 0.00179
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && flag2 <= 1 && x <= 1 && turn + flag1 <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && flag2 <= 1 && x <= 1 && turn + flag1 <= -1 && 0 < x + flag2 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001845
Prover Time taken = 0.001834
Prover Time taken = 0.002158
Prover Time taken = 0.003033
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && flag2 <= 1 && x <= 1 && turn + flag1 <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && flag2 <= 1 && x <= 1 && turn + flag1 <= -1 && 0 < x + flag2 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002654
Prover Time taken = 0.002503
Prover Time taken = 0.002054
Prover Time taken = 0.002137
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && flag2 <= 1 && x <= 1 && turn + flag1 <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && flag2 <= 1 && x <= 1 && turn + flag1 <= -1 && 0 < x + flag2 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.003415
Added Horn clause: 228 => 229
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0286720
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 - flag2 <= 0 && x + flag1 <= -1 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && 0 < flag1 - flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001794
Prover Time taken = 0.002281
Prover Time taken = 0.001413
Prover Time taken = 0.001884
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 - flag2 <= 0 && x + flag1 <= -1 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && 0 < flag1 - flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001341
Prover Time taken = 0.001558
Prover Time taken = 0.00136
Prover Time taken = 0.001421
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 - flag2 <= 0 && x + flag1 <= -1 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && 0 < flag1 - flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001711
Prover Time taken = 0.001816
Prover Time taken = 0.001854
Prover Time taken = 0.001553
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 - flag2 <= 0 && x + flag1 <= -1 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && 0 < flag1 - flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.003784
Added Horn clause: 230 => 231
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0279370
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && 0 < turn + flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && 0 < x + flag2 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001702
Prover Time taken = 0.002069
Prover Time taken = 0.00138
Prover Time taken = 0.001992
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && 0 < turn + flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && 0 < x + flag2 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003312
Prover Time taken = 0.002032
Prover Time taken = 0.001389
Prover Time taken = 0.00136
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && 0 < turn + flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && 0 < x + flag2 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.00192
Prover Time taken = 0.00191
Prover Time taken = 0.00163
Prover Time taken = 0.002099
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && 0 < x + flag2 && flag2 <= 1 && 0 < turn + flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && turn + flag1 <= 0 && 0 < x + flag2 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.00326
Added Horn clause: 232 => 233
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0298910
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && x + flag1 <= 0 && turn - flag2 <= 0 && x + turn <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && x + flag1 <= 0 && turn - flag2 <= 0 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && 1 < flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 0 < flag1 - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002609
Prover Time taken = 0.002828
Prover Time taken = 0.002048
Prover Time taken = 0.002007
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && x + flag1 <= 0 && turn - flag2 <= 0 && x + turn <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && x + flag1 <= 0 && turn - flag2 <= 0 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && 1 < flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 0 < flag1 - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002022
Prover Time taken = 0.002365
Prover Time taken = 0.002215
Prover Time taken = 0.002117
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && x + flag1 <= 0 && turn - flag2 <= 0 && x + turn <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && x + flag1 <= 0 && turn - flag2 <= 0 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && 1 < flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 0 < flag1 - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002223
Prover Time taken = 0.002579
Prover Time taken = 0.003795
Prover Time taken = 0.003271
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && x + flag1 <= 0 && turn - flag2 <= 0 && x + turn <= -1 && x + flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && x + flag1 <= 0 && turn - flag2 <= 0 && -1 < x + turn) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && 1 < flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 0 < flag1 - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.004368
Added Horn clause: 203 => 234
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0322720
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && turn + flag1 <= -1 && flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && turn + flag1 <= -1 && 0 < flag2 && x - turn <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && 1 < flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 0 < flag1 - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002349
Prover Time taken = 0.002227
Prover Time taken = 0.002054
Prover Time taken = 0.002136
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && turn + flag1 <= -1 && flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && turn + flag1 <= -1 && 0 < flag2 && x - turn <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && 1 < flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 0 < flag1 - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00227
Prover Time taken = 0.002401
Prover Time taken = 0.002151
Prover Time taken = 0.001945
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && turn + flag1 <= -1 && flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && turn + flag1 <= -1 && 0 < flag2 && x - turn <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && 1 < flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 0 < flag1 - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001926
Prover Time taken = 0.002057
Prover Time taken = 0.002743
Prover Time taken = 0.002307
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && turn + flag1 <= -1 && flag2 <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && flag2 <= 1 && turn + flag1 <= -1 && 0 < flag2 && x - turn <= 0) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag1 - flag2 <= 0 && 1 < flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 0 < flag1 - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.003753
Added Horn clause: 208 => 235
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0330910
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && x + flag2 <= -1) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= -1) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && -1 < x + flag2 && -1 < turn - flag1 && 0 < turn && 0 < x + flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002071
Prover Time taken = 0.001695
Prover Time taken = 0.002273
Prover Time taken = 0.001964
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && x + flag2 <= -1) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= -1) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && -1 < x + flag2 && -1 < turn - flag1 && 0 < turn && 0 < x + flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001711
Prover Time taken = 0.002316
Prover Time taken = 0.002612
Prover Time taken = 0.00214
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && x + flag2 <= -1) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= -1) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && -1 < x + flag2 && -1 < turn - flag1 && 0 < turn && 0 < x + flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002133
Prover Time taken = 0.002169
Prover Time taken = 0.001976
Prover Time taken = 0.002433
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= -1 || (-1 < x && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && x + flag2 <= -1) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= -1) || (x + flag1 <= 1 && 0 < x && x <= 1 && flag2 <= 1 && flag1 + flag2 <= 0 && -1 < x + flag2 && -1 < turn - flag1 && 0 < turn && 0 < x + flag2) || (x + flag1 <= 1 && 0 < x && x <= 1 && 1 < flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.003807
Added Horn clause: 236 => 65
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0276000
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && x <= 0)
}
Prover Time taken = 0.001079
Prover Time taken = 0.001111
Prover Time taken = 0.000821
Prover Time taken = 0.001082
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001098
Prover Time taken = 0.00111
Prover Time taken = 0.001585
Prover Time taken = 0.001101
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001099
Prover Time taken = 0.001316
Prover Time taken = 0.001171
Prover Time taken = 0.00118
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.002063
Prover Time taken = 0.001885
Prover Time taken = 0.001733
Prover Time taken = 0.00144
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.003174
Added Horn clause: 237 => 215
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0245980
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && x <= 0 && x - flag2 <= 0)
}
Prover Time taken = 0.001092
Prover Time taken = 0.001812
Prover Time taken = 0.000868
Prover Time taken = 0.000826
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && x <= 0 && x - flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.00279
Added Horn clause: 238 => 227
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0251100
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && x <= 0 && x - turn <= -1)
}
Prover Time taken = 0.00257
Prover Time taken = 0.000949
Prover Time taken = 0.00082
Prover Time taken = 0.000762
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && x <= 0 && x - turn <= -1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.003397
Added Horn clause: 239 => 240
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0284640
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && x <= 0 && 0 < flag1)
}
Prover Time taken = 0.001093
Prover Time taken = 0.00088
Prover Time taken = 0.000859
Prover Time taken = 0.001075
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && x <= 0 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.003417
Added Horn clause: 241 => 124
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0274080
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && turn - flag2 <= -1 && 0 < turn + flag1) || (1 < x + flag1 && 1 < flag1 && -1 < turn - flag2 && 0 < turn - flag2 && 0 < turn + flag2)
}
Prover Time taken = 0.001392
Prover Time taken = 0.001371
Prover Time taken = 0.001403
Prover Time taken = 0.001195
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && turn - flag2 <= -1 && 0 < turn + flag1) || (1 < x + flag1 && 1 < flag1 && -1 < turn - flag2 && 0 < turn - flag2 && 0 < turn + flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001209
Prover Time taken = 0.001294
Prover Time taken = 0.001256
Prover Time taken = 0.001249
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && turn - flag2 <= -1 && 0 < turn + flag1) || (1 < x + flag1 && 1 < flag1 && -1 < turn - flag2 && 0 < turn - flag2 && 0 < turn + flag2)
}
Added: P2:0,-1,2,2: negative
Prover Time taken = 0.003445
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0264460
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && 1 < turn + flag2) || (-1 < x && x <= 0 && 1 < turn)
}
Prover Time taken = 0.001296
Prover Time taken = 0.000933
Prover Time taken = 0.000935
Prover Time taken = 0.000931
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x + flag1
}
Prover Time taken = 0.000867
Prover Time taken = 0.000757
Prover Time taken = 0.000768
Prover Time taken = 0.000806
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x + flag1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000739
Prover Time taken = 0.000818
Prover Time taken = 0.000845
Prover Time taken = 0.000646
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x + flag1
}
Added: P2:-1,2,2,0: negative
Prover Time taken = 0.003733
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0279690
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x + flag2
}
Prover Time taken = 0.001131
Prover Time taken = 0.000927
Prover Time taken = 0.000889
Prover Time taken = 0.001059
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x + flag2
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000969
Prover Time taken = 0.000872
Prover Time taken = 0.000772
Prover Time taken = 0.000871
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x + flag2
}
Prover Time taken = 0.000972
Added: P2:0,5,-5,1: negative
Prover Time taken = 0.002676
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0283980
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 1 < x + flag1
}
Prover Time taken = 0.001122
Prover Time taken = 0.000687
Prover Time taken = 0.00065
Prover Time taken = 0.000714
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 1 < x + flag1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000856
Prover Time taken = 0.000716
Prover Time taken = 0.000678
Prover Time taken = 0.000745
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 1 < x + flag1
}
Added: P2:0,2,2,0: negative
Prover Time taken = 0.002436
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0280940
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x && 0 < x + flag1
}
Prover Time taken = 0.000906
Prover Time taken = 0.000738
Prover Time taken = 0.000979
Prover Time taken = 0.000683
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x && 0 < x + flag1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000967
Prover Time taken = 0.001036
Prover Time taken = 0.000703
Prover Time taken = 0.000801
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x && 0 < x + flag1
}
Prover Time taken = 0.00087
Prover Time taken = 0.000768
Prover Time taken = 0.00076
Prover Time taken = 0.000758
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && 1 < turn + flag2) || (-1 < x && x <= 0 && 1 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x && 0 < x + flag1
}
Prover Time taken = 0.003616
Added Horn clause: 246 => 30
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0285650
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && flag1 <= 1 && -1 < x + turn) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && flag2 <= 1) || (-1 < x && x <= 0 && 1 < turn)
}
Prover Time taken = 0.001361
Prover Time taken = 0.001267
Prover Time taken = 0.00098
Prover Time taken = 0.000996
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && flag1 <= 1 && -1 < x + turn) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && flag2 <= 1) || (-1 < x && x <= 0 && 1 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x && 0 < x + flag1
}
Prover Time taken = 0.002837
Added Horn clause: 247 => 248
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0271690
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && flag1 <= 1 && -1 < x + turn && x + flag2 <= 0) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && flag2 <= 1) || (-1 < x && x <= 0 && 1 < turn)
}
Prover Time taken = 0.001491
Prover Time taken = 0.000977
Prover Time taken = 0.000909
Prover Time taken = 0.001052
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && flag1 <= 1 && -1 < x + turn && x + flag2 <= 0) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && flag2 <= 1) || (-1 < x && x <= 0 && 1 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x && 0 < x + flag1
}
Prover Time taken = 0.003739
Added Horn clause: 33 => 27
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0267220
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && flag1 <= 1 && -1 < x + turn && 0 < flag2 && x + flag2 <= 0) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && flag2 <= 1) || (-1 < x && x <= 0 && 1 < turn)
}
Prover Time taken = 0.001684
Prover Time taken = 0.001445
Prover Time taken = 0.001335
Prover Time taken = 0.001555
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && flag1 <= 1 && -1 < x + turn && 0 < flag2 && x + flag2 <= 0) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && flag2 <= 1) || (-1 < x && x <= 0 && 1 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn && 1 < turn - flag2 && 0 < x && 0 < x + flag1
}
Prover Time taken = 0.00287
Added Horn clause: 25 => 30
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0324360
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && x <= 0 && 0 < flag1)
}
Prover Time taken = 0.00096
Prover Time taken = 0.000779
Prover Time taken = 0.001023
Prover Time taken = 0.000744
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && turn <= 1) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && 1 < turn && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001555
Prover Time taken = 0.001266
Prover Time taken = 0.001116
Prover Time taken = 0.001551
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && turn <= 1) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && 1 < turn && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001359
Prover Time taken = 0.00161
Prover Time taken = 0.001531
Prover Time taken = 0.001285
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && turn <= 1) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && 1 < turn && 0 < turn - flag1 && 0 < x)
}
Added: P2:0,0,2,2: negative
Prover Time taken = 0.003194
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0290540
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && turn <= 1 && 0 < turn) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && 1 < turn && 0 < turn - flag1 && 0 < x)
}
Prover Time taken = 0.001719
Prover Time taken = 0.001562
Prover Time taken = 0.001958
Prover Time taken = 0.001686
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && turn <= 1 && 0 < turn) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && 1 < turn && 0 < turn - flag1 && 0 < x)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001771
Prover Time taken = 0.00164
Prover Time taken = 0.001583
Prover Time taken = 0.00154
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && turn <= 1 && 0 < turn) || (1 < x + flag1 && 1 < flag1 && 1 < turn + flag2 && 1 < turn && 0 < turn - flag1 && 0 < x)
}
Overwrote: P2:0,1,2,2: negative
Prover Time taken = 0.004046
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0296390
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && 0 < turn + flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1)
}
Prover Time taken = 0.001365
Prover Time taken = 0.001372
Prover Time taken = 0.000901
Prover Time taken = 0.000886
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.001109
Prover Time taken = 0.001444
Prover Time taken = 0.000984
Prover Time taken = 0.001008
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001023
Prover Time taken = 0.002383
Prover Time taken = 0.001399
Prover Time taken = 0.00117
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.001305
Prover Time taken = 0.001228
Prover Time taken = 0.001415
Prover Time taken = 0.001165
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && 0 < turn + flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.004251
Added Horn clause: 250 => 251
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0317810
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && flag2 <= 1) || (-1 < x && x <= 0 && 0 < flag1)
}
Prover Time taken = 0.001114
Prover Time taken = 0.001477
Prover Time taken = 0.001009
Prover Time taken = 0.001204
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag2)
}
Prover Time taken = 0.001111
Prover Time taken = 0.001077
Prover Time taken = 0.001025
Prover Time taken = 0.000967
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000959
Prover Time taken = 0.000917
Prover Time taken = 0.001115
Prover Time taken = 0.000801
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag2)
}
Prover Time taken = 0.001008
Prover Time taken = 0.000967
Prover Time taken = 0.001053
Prover Time taken = 0.001155
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && flag2 <= 1) || (-1 < x && x <= 0 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag2)
}
Prover Time taken = 0.002978
Added Horn clause: 252 => 253
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0312580
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1)
}
Prover Time taken = 0.001201
Prover Time taken = 0.001252
Prover Time taken = 0.000894
Prover Time taken = 0.000998
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.001124
Prover Time taken = 0.001062
Prover Time taken = 0.001042
Prover Time taken = 0.001074
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001088
Prover Time taken = 0.001286
Prover Time taken = 0.000894
Prover Time taken = 0.001087
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.001555
Prover Time taken = 0.001424
Prover Time taken = 0.001505
Prover Time taken = 0.001647
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.003116
Added Horn clause: 254 => 124
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0315350
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001375
Prover Time taken = 0.001152
Prover Time taken = 0.001256
Prover Time taken = 0.00147
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && x <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.002982
Added Horn clause: 255 => 256
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0316230
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < x + flag1)
}
Prover Time taken = 0.001197
Prover Time taken = 0.000977
Prover Time taken = 0.000936
Prover Time taken = 0.001178
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001289
Prover Time taken = 0.001228
Prover Time taken = 0.001369
Prover Time taken = 0.001226
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001738
Prover Time taken = 0.00116
Prover Time taken = 0.001033
Prover Time taken = 0.001058
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001581
Prover Time taken = 0.001803
Prover Time taken = 0.001664
Prover Time taken = 0.001567
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < x + flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.003718
Added Horn clause: 257 => 258
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0288830
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1)
}
Prover Time taken = 0.00123
Prover Time taken = 0.001196
Prover Time taken = 0.001372
Prover Time taken = 0.001156
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.0048
Added Horn clause: 259 => 260
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0330120
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 1 < turn + flag1)
}
Prover Time taken = 0.001414
Prover Time taken = 0.001158
Prover Time taken = 0.001108
Prover Time taken = 0.001275
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 1 < turn + flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.003777
Added Horn clause: 261 => 262
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0304500
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
Prover Time taken = 0.001073
Prover Time taken = 0.001284
Prover Time taken = 0.001186
Prover Time taken = 0.00121
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.001323
Prover Time taken = 0.001623
Prover Time taken = 0.001315
Prover Time taken = 0.00149
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001039
Prover Time taken = 0.00097
Prover Time taken = 0.001277
Prover Time taken = 0.000925
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.003072
Prover Time taken = 0.001522
Prover Time taken = 0.001444
Prover Time taken = 0.001557
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 0 < turn - flag1 && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.001973
Prover Time taken = 0.002972
Added Horn clause: 263 => 264
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0314640
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001905
Prover Time taken = 0.001254
Prover Time taken = 0.001754
Prover Time taken = 0.001517
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001194
Prover Time taken = 0.001162
Prover Time taken = 0.001106
Prover Time taken = 0.001097
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001725
Prover Time taken = 0.002055
Prover Time taken = 0.002066
Prover Time taken = 0.001866
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001879
Prover Time taken = 0.002465
Prover Time taken = 0.00177
Prover Time taken = 0.001903
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002217
Prover Time taken = 0.002008
Prover Time taken = 0.001946
Prover Time taken = 0.003429
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003977
Added Horn clause: 265 && 266 => 225
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0385930
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001781
Prover Time taken = 0.0016
Prover Time taken = 0.001456
Prover Time taken = 0.001549
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00132
Prover Time taken = 0.001341
Prover Time taken = 0.001271
Prover Time taken = 0.001167
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.00173
Prover Time taken = 0.002017
Prover Time taken = 0.001975
Prover Time taken = 0.002119
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 0 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.003702
Added Horn clause: 267 => 268
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0334720
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.001488
Prover Time taken = 0.001372
Prover Time taken = 0.001222
Prover Time taken = 0.001242
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001115
Prover Time taken = 0.001005
Prover Time taken = 0.001109
Prover Time taken = 0.001331
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.001617
Prover Time taken = 0.001511
Prover Time taken = 0.001566
Prover Time taken = 0.001514
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.003442
Added Horn clause: 269 => 265
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0348750
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
Prover Time taken = 0.001692
Prover Time taken = 0.001121
Prover Time taken = 0.001158
Prover Time taken = 0.001354
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.002871
Added Horn clause: 270 => 271
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0326810
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && x - turn <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.001445
Prover Time taken = 0.001156
Prover Time taken = 0.001078
Prover Time taken = 0.001321
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && x - turn <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001136
Prover Time taken = 0.001091
Prover Time taken = 0.000979
Prover Time taken = 0.00104
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && x - turn <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.002113
Prover Time taken = 0.001597
Prover Time taken = 0.001625
Prover Time taken = 0.001738
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && x - turn <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.003992
Added Horn clause: 272 => 273
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0321820
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001818
Prover Time taken = 0.001731
Prover Time taken = 0.001651
Prover Time taken = 0.001658
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001609
Prover Time taken = 0.001581
Prover Time taken = 0.001584
Prover Time taken = 0.001618
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.0046
Prover Time taken = 0.00198
Prover Time taken = 0.001823
Prover Time taken = 0.00168
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x - turn <= 1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.004445
Added Horn clause: 274 => 275
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0399320
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001859
Prover Time taken = 0.001386
Prover Time taken = 0.001413
Prover Time taken = 0.001376
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002106
Prover Time taken = 0.002155
Prover Time taken = 0.001528
Prover Time taken = 0.001553
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.002222
Prover Time taken = 0.002066
Prover Time taken = 0.001884
Prover Time taken = 0.002132
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < turn + flag1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.004551
Added Horn clause: 276 => 277
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0491520
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x - turn <= 1 && x + flag2 <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x - turn <= 1 && 1 < x + flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < flag2)
}
Prover Time taken = 0.001645
Prover Time taken = 0.001497
Prover Time taken = 0.001576
Prover Time taken = 0.001173
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x - turn <= 1 && x + flag2 <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x - turn <= 1 && 1 < x + flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001336
Prover Time taken = 0.002065
Prover Time taken = 0.001683
Prover Time taken = 0.001568
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x - turn <= 1 && x + flag2 <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x - turn <= 1 && 1 < x + flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < flag2)
}
Prover Time taken = 0.001687
Prover Time taken = 0.001488
Prover Time taken = 0.001557
Prover Time taken = 0.001575
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x - turn <= 1 && x + flag2 <= 1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x - turn <= 1 && 1 < x + flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < flag2)
}
Prover Time taken = 0.004243
Added Horn clause: 278 => 279
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0401800
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x + flag2 <= 1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x + flag2 <= 1 && -1 < x + flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && 1 < x + flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < flag2)
}
Prover Time taken = 0.001469
Prover Time taken = 0.001489
Prover Time taken = 0.00132
Prover Time taken = 0.001332
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x + flag2 <= 1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x + flag2 <= 1 && -1 < x + flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && 1 < x + flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00127
Prover Time taken = 0.001185
Prover Time taken = 0.001236
Prover Time taken = 0.00126
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x + flag2 <= 1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x + flag2 <= 1 && -1 < x + flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && 1 < x + flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < flag2)
}
Prover Time taken = 0.001661
Prover Time taken = 0.003184
Prover Time taken = 0.001435
Prover Time taken = 0.00141
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && x + flag1 <= 1 && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x + flag2 <= 1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && x + flag2 <= 1 && -1 < x + flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && flag2 <= 1 && 1 < x + flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && 1 < flag2)
}
Prover Time taken = 0.004438
Added Horn clause: 280 => 265
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0452570
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1)
}
Prover Time taken = 0.002124
Prover Time taken = 0.001951
Prover Time taken = 0.001429
Prover Time taken = 0.001456
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.002095
Prover Time taken = 0.002228
Prover Time taken = 0.002326
Prover Time taken = 0.002503
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001624
Prover Time taken = 0.001582
Prover Time taken = 0.001979
Prover Time taken = 0.001575
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.002452
Prover Time taken = 0.00243
Prover Time taken = 0.002241
Prover Time taken = 0.002337
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.003481
Prover Time taken = 0.005781
Added Horn clause: 281 => 282
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0498740
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.002306
Prover Time taken = 0.002004
Prover Time taken = 0.002164
Prover Time taken = 0.002329
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001734
Prover Time taken = 0.0017
Prover Time taken = 0.00149
Prover Time taken = 0.001555
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.001844
Prover Time taken = 0.002174
Prover Time taken = 0.002723
Prover Time taken = 0.001654
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
Prover Time taken = 0.003443
Prover Time taken = 0.002359
Prover Time taken = 0.002352
Prover Time taken = 0.003277
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003599
Prover Time taken = 0.003628
Prover Time taken = 0.004164
Prover Time taken = 0.004446
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && x + flag2 <= -1 && 0 < turn - flag2) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && flag2 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && flag2 <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1) || (1 < x + flag1 && flag1 <= 1 && 0 < flag1 && -1 < x + flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.009321
Added Horn clause: 283 && 284 => 285
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0511980
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < x + turn) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
Prover Time taken = 0.001901
Prover Time taken = 0.001745
Prover Time taken = 0.001687
Prover Time taken = 0.001711
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.002837
Prover Time taken = 0.002588
Prover Time taken = 0.00256
Prover Time taken = 0.002894
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && 1 < turn - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001715
Prover Time taken = 0.001996
Prover Time taken = 0.002095
Prover Time taken = 0.002169
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.002261
Prover Time taken = 0.00234
Prover Time taken = 0.002412
Prover Time taken = 0.002905
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < x + turn) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.005998
Added Horn clause: 286 => 271
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0555090
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
Prover Time taken = 0.001769
Prover Time taken = 0.001766
Prover Time taken = 0.00165
Prover Time taken = 0.001725
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.005601
Added Horn clause: 287 => 271
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0574960
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < turn + flag2)
}
Prover Time taken = 0.002308
Prover Time taken = 0.003694
Prover Time taken = 0.001746
Prover Time taken = 0.001803
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < turn + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.005106
Added Horn clause: 288 => 283
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0600610
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < flag1 + flag2)
}
Prover Time taken = 0.001769
Prover Time taken = 0.001624
Prover Time taken = 0.001923
Prover Time taken = 0.001737
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < flag1 + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < turn - flag2 && 1 < turn - flag2)
}
Prover Time taken = 0.005575
Added Horn clause: 289 => 283
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0530710
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < flag1 + flag2)
}
Prover Time taken = 0.002315
Prover Time taken = 0.001942
Prover Time taken = 0.002958
Prover Time taken = 0.002367
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.002731
Prover Time taken = 0.002424
Prover Time taken = 0.002265
Prover Time taken = 0.002725
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002372
Prover Time taken = 0.00225
Prover Time taken = 0.001978
Prover Time taken = 0.002586
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.002667
Prover Time taken = 0.002874
Prover Time taken = 0.002686
Prover Time taken = 0.002883
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && -1 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < flag1 + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.003929
Prover Time taken = 0.005489
Prover Time taken = 0.002955
Prover Time taken = 0.004262
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002742
Prover Time taken = 0.003604
Prover Time taken = 0.002941
Prover Time taken = 0.003169
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && -1 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.007204
Added Horn clause: 290 && 291 => 292
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0590110
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1)
}
Prover Time taken = 0.001576
Prover Time taken = 0.001403
Prover Time taken = 0.00135
Prover Time taken = 0.001655
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < turn && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < turn && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001958
Prover Time taken = 0.001838
Prover Time taken = 0.001591
Prover Time taken = 0.001581
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < turn && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < turn && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002134
Prover Time taken = 0.002362
Prover Time taken = 0.00181
Prover Time taken = 0.001937
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && -1 < turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < turn && 0 < turn - flag1 && turn - flag1 <= 1 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < turn && 0 < turn - flag1 && turn - flag1 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (0 < flag1 && flag1 <= 1 && -1 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Added: P2:0,1,1,-2: negative
Prover Time taken = 0.004731
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0568670
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && x - turn <= -1)
}
Prover Time taken = 0.0027
Prover Time taken = 0.002274
Prover Time taken = 0.002321
Prover Time taken = 0.002704
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 1 < x + turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && 1 < turn - flag2)
}
Prover Time taken = 0.002325
Prover Time taken = 0.002367
Prover Time taken = 0.002063
Prover Time taken = 0.002031
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 1 < x + turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && 1 < turn - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001926
Prover Time taken = 0.002296
Prover Time taken = 0.002961
Prover Time taken = 0.001552
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 1 < x + turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && turn - flag2 <= 1 && 1 < flag2) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && 1 < turn - flag2)
}
Added: P2:0,2,1,2: negative
Prover Time taken = 0.005355
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0651030
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < flag1 + flag2)
}
Prover Time taken = 0.001745
Prover Time taken = 0.001547
Prover Time taken = 0.001459
Prover Time taken = 0.001482
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.002051
Prover Time taken = 0.002182
Prover Time taken = 0.002019
Prover Time taken = 0.002267
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002834
Prover Time taken = 0.002571
Prover Time taken = 0.00219
Prover Time taken = 0.001588
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.003222
Prover Time taken = 0.00314
Prover Time taken = 0.002986
Prover Time taken = 0.002558
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < flag1 + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.005138
Added Horn clause: 295 => 296
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0833970
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.003537
Prover Time taken = 0.003137
Prover Time taken = 0.002972
Prover Time taken = 0.003546
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002233
Prover Time taken = 0.005407
Prover Time taken = 0.002985
Prover Time taken = 0.002677
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.002988
Prover Time taken = 0.002393
Prover Time taken = 0.00214
Prover Time taken = 0.002639
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < flag1 + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.005265
Added Horn clause: 297 => 290
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0580090
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < flag1 + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < flag1 + flag2)
}
Prover Time taken = 0.001685
Prover Time taken = 0.001547
Prover Time taken = 0.00127
Prover Time taken = 0.001525
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < flag1 + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && -1 < flag1 + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.007149
Added Horn clause: 298 => 290
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0552900
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < flag1 + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && x - flag2 <= 0)
}
Prover Time taken = 0.001513
Prover Time taken = 0.001439
Prover Time taken = 0.001587
Prover Time taken = 0.001708
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < flag1 + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && x - flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.003034
Prover Time taken = 0.003096
Prover Time taken = 0.002697
Prover Time taken = 0.002918
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00338
Prover Time taken = 0.003769
Prover Time taken = 0.003106
Prover Time taken = 0.003739
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && x + flag2 <= -1 && -1 < turn + flag1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && x + flag2 <= 0 && -1 < x + flag2 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x && 0 < x + flag2 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.006208
Added Horn clause: 273 && 299 => 300
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0487090
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && x - turn <= -1)
}
Prover Time taken = 0.004015
Prover Time taken = 0.001488
Prover Time taken = 0.001586
Prover Time taken = 0.00167
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 1 < x + turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && turn - flag2 <= 1 && 0 < x && 1 < flag2) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && 1 < turn - flag2)
}
Prover Time taken = 0.002175
Prover Time taken = 0.002046
Prover Time taken = 0.002056
Prover Time taken = 0.001902
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 1 < x + turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && turn - flag2 <= 1 && 0 < x && 1 < flag2) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && 1 < turn - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001489
Prover Time taken = 0.001526
Prover Time taken = 0.001513
Prover Time taken = 0.001922
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 1 < x + turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && turn - flag2 <= 1 && 0 < x && 1 < flag2) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && 1 < turn - flag2)
}
Added: P2:0,2,1,0: negative
Prover Time taken = 0.003694
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0584100
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && 0 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < flag1 + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && x - flag2 <= 0)
}
Prover Time taken = 0.001712
Prover Time taken = 0.001506
Prover Time taken = 0.001608
Prover Time taken = 0.001904
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.001786
Prover Time taken = 0.001754
Prover Time taken = 0.001437
Prover Time taken = 0.00181
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001824
Prover Time taken = 0.002444
Prover Time taken = 0.001858
Prover Time taken = 0.002807
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.003517
Prover Time taken = 0.001927
Prover Time taken = 0.001491
Prover Time taken = 0.001724
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && -1 < turn - flag1 && 0 < turn + flag2) || (x <= -1 && 1 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < flag1 + flag2) || (-1 < x && 0 < turn - flag2 && 0 < flag1 && flag1 <= 1 && x - flag2 <= 0)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.003142
Prover Time taken = 0.003236
Prover Time taken = 0.003432
Prover Time taken = 0.002456
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002598
Prover Time taken = 0.002311
Prover Time taken = 0.002382
Prover Time taken = 0.002459
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < x && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.005363
Added Horn clause: 3 && 302 => 301
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0526470
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 1 < turn)
}
Prover Time taken = 0.001272
Prover Time taken = 0.001195
Prover Time taken = 0.001366
Prover Time taken = 0.001589
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.002111
Prover Time taken = 0.001782
Prover Time taken = 0.002309
Prover Time taken = 0.002229
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
Prover Time taken = 0.001257
Prover Time taken = 0.00082
Prover Time taken = 0.000842
Prover Time taken = 0.001101
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001315
Prover Time taken = 0.001747
Prover Time taken = 0.00131
Prover Time taken = 0.001718
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.002072
Prover Time taken = 0.002136
Prover Time taken = 0.001774
Prover Time taken = 0.001603
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 1 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.004436
Added Horn clause: 303 => 304
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0527020
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1)
}
Prover Time taken = 0.00149
Prover Time taken = 0.001107
Prover Time taken = 0.001571
Prover Time taken = 0.001061
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.004349
Prover Time taken = 0.00236
Prover Time taken = 0.001761
Prover Time taken = 0.002921
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003096
Prover Time taken = 0.003066
Prover Time taken = 0.002507
Prover Time taken = 0.002429
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
Prover Time taken = 0.004626
Added Horn clause: 55 && 305 => 294
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0576000
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1)
}
Prover Time taken = 0.001434
Prover Time taken = 0.001572
Prover Time taken = 0.001378
Prover Time taken = 0.001348
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && turn - flag2 <= -1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && -1 < turn - flag2 && 0 < turn - flag2)
}
Prover Time taken = 0.002353
Prover Time taken = 0.001834
Prover Time taken = 0.001767
Prover Time taken = 0.0015
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && turn - flag2 <= -1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && -1 < turn - flag2 && 0 < turn - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001677
Prover Time taken = 0.001961
Prover Time taken = 0.00142
Prover Time taken = 0.001544
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && turn - flag2 <= -1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && -1 < turn - flag2 && 0 < turn - flag2)
}
Prover Time taken = 0.002531
Prover Time taken = 0.002786
Prover Time taken = 0.002262
Prover Time taken = 0.002011
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && turn - flag2 <= -1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && -1 < turn - flag2 && 0 < turn - flag2)
}
Prover Time taken = 0.005048
Added Horn clause: 306 => 307
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0550660
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1)
}
Prover Time taken = 0.001233
Prover Time taken = 0.00129
Prover Time taken = 0.00157
Prover Time taken = 0.001372
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && turn - flag2 <= -1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && -1 < turn - flag2 && 0 < turn - flag2)
}
Prover Time taken = 0.005173
Added Horn clause: 308 => 55
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0531360
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
Prover Time taken = 0.001531
Prover Time taken = 0.003195
Prover Time taken = 0.002635
Prover Time taken = 0.001693
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001623
Prover Time taken = 0.001968
Prover Time taken = 0.001513
Prover Time taken = 0.001709
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001231
Prover Time taken = 0.001238
Prover Time taken = 0.001609
Prover Time taken = 0.001113
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001387
Prover Time taken = 0.001658
Prover Time taken = 0.001331
Prover Time taken = 0.001299
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001954
Prover Time taken = 0.003813
Prover Time taken = 0.002044
Prover Time taken = 0.00212
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002883
Prover Time taken = 0.002654
Prover Time taken = 0.00281
Prover Time taken = 0.001927
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
Prover Time taken = 0.003973
Added Horn clause: 309 && 310 => 311
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0570780
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001392
Prover Time taken = 0.001271
Prover Time taken = 0.001752
Prover Time taken = 0.001214
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001545
Prover Time taken = 0.001556
Prover Time taken = 0.001263
Prover Time taken = 0.001556
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001479
Prover Time taken = 0.001382
Prover Time taken = 0.001373
Prover Time taken = 0.001381
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.004602
Added Horn clause: 312 => 309
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0562560
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && -1 < turn - flag1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
Prover Time taken = 0.001629
Prover Time taken = 0.001254
Prover Time taken = 0.001378
Prover Time taken = 0.001566
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && -1 < turn - flag1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.005321
Added Horn clause: 313 => 314
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0653340
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && 1 < turn + flag2) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
Prover Time taken = 0.0014
Prover Time taken = 0.001205
Prover Time taken = 0.001151
Prover Time taken = 0.001081
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && 1 < turn + flag2) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.004832
Added Horn clause: 315 => 316
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0636020
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
Prover Time taken = 0.001263
Prover Time taken = 0.001048
Prover Time taken = 0.000911
Prover Time taken = 0.001332
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.003537
Added Horn clause: 317 => 318
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0614400
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && x + turn <= -1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && -1 < x + turn && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && -1 < x + turn && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001667
Prover Time taken = 0.001473
Prover Time taken = 0.001407
Prover Time taken = 0.001565
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && x + turn <= -1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && -1 < x + turn && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && -1 < x + turn && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001473
Prover Time taken = 0.002185
Prover Time taken = 0.002126
Prover Time taken = 0.002365
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && x + turn <= -1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && -1 < x + turn && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && -1 < x + turn && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.002748
Prover Time taken = 0.002501
Prover Time taken = 0.00208
Prover Time taken = 0.002
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && x + turn <= -1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && -1 < x + turn && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && -1 < x + turn && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.004518
Added Horn clause: 319 => 320
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0567180
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && x + turn <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < x + turn && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < x + turn && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.003264
Prover Time taken = 0.002268
Prover Time taken = 0.001711
Prover Time taken = 0.001729
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && x + turn <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < x + turn && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < x + turn && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001485
Prover Time taken = 0.001896
Prover Time taken = 0.001257
Prover Time taken = 0.001408
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && x + turn <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < x + turn && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < x + turn && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.001673
Prover Time taken = 0.001544
Prover Time taken = 0.001593
Prover Time taken = 0.001652
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && x + turn <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < x + turn && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < x + turn && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.003508
Added Horn clause: 321 => 309
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0633100
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < turn - flag2)
}
Prover Time taken = 0.001456
Prover Time taken = 0.001236
Prover Time taken = 0.00234
Prover Time taken = 0.001602
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && 0 < turn - flag2)
}
Prover Time taken = 0.002338
Prover Time taken = 0.002092
Prover Time taken = 0.002378
Prover Time taken = 0.002205
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && 0 < turn - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00189
Prover Time taken = 0.002007
Prover Time taken = 0.003486
Prover Time taken = 0.002117
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && 0 < turn - flag2)
}
Prover Time taken = 0.002262
Prover Time taken = 0.001823
Prover Time taken = 0.002465
Prover Time taken = 0.002483
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < turn - flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && 0 < turn - flag2)
}
Prover Time taken = 0.003533
Prover Time taken = 0.002238
Prover Time taken = 0.003656
Prover Time taken = 0.002351
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && 0 < turn - flag2)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002838
Prover Time taken = 0.00237
Prover Time taken = 0.002999
Prover Time taken = 0.003082
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && 0 < turn - flag1 && 1 < turn - flag1) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && 1 < flag2 && 0 < turn - flag2)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
Prover Time taken = 0.003466
Prover Time taken = 0.005907
Added Horn clause: 282 && 322 => 323
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0639800
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < flag1 + flag2) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && x - flag2 <= 0 && flag2 <= 1)
}
Prover Time taken = 0.002101
Prover Time taken = 0.002013
Prover Time taken = 0.001883
Prover Time taken = 0.002164
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Prover Time taken = 0.00406
Prover Time taken = 0.001448
Prover Time taken = 0.001287
Prover Time taken = 0.002071
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001557
Prover Time taken = 0.001398
Prover Time taken = 0.001231
Prover Time taken = 0.00115
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && flag2 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 0 < x + flag2 && 0 < flag2 && flag2 <= 1 && 0 < turn - flag1 && 1 < turn - flag1)
}
Added: P2:0,1,1,1: negative
Prover Time taken = 0.003971
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0775760
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < turn && 0 < turn - flag2 && turn - flag1 <= 1)
}
Prover Time taken = 0.001711
Prover Time taken = 0.0019
Prover Time taken = 0.001745
Prover Time taken = 0.00183
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 1 < x + turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && 0 < x - flag2)
}
Prover Time taken = 0.001742
Prover Time taken = 0.001655
Prover Time taken = 0.00176
Prover Time taken = 0.001646
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 1 < x + turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && 0 < x - flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001451
Prover Time taken = 0.001526
Prover Time taken = 0.001623
Prover Time taken = 0.001594
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && flag1 <= 1 && 1 < x + turn && turn - flag1 <= 0) || (0 < flag1 && flag1 <= 1 && 1 < x + turn && 0 < turn - flag1 && 0 < x - flag2)
}
Overwrote: P2:0,2,1,-1: negative
Prover Time taken = 0.003943
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0698160
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.002135
Prover Time taken = 0.002347
Prover Time taken = 0.001957
Prover Time taken = 0.002181
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
Prover Time taken = 0.002053
Prover Time taken = 0.001724
Prover Time taken = 0.001329
Prover Time taken = 0.001375
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001182
Prover Time taken = 0.001145
Prover Time taken = 0.001179
Prover Time taken = 0.001581
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
Prover Time taken = 0.001439
Prover Time taken = 0.001577
Prover Time taken = 0.001241
Prover Time taken = 0.001468
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
Prover Time taken = 0.002807
Prover Time taken = 0.005045
Added Horn clause: 325 => 282
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0656080
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && flag2 <= 0) || (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < flag2 && 0 < turn && turn - flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001897
Prover Time taken = 0.00219
Prover Time taken = 0.002413
Prover Time taken = 0.002707
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && flag2 <= 0) || (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < flag2 && 0 < turn && turn - flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
Prover Time taken = 0.004683
Prover Time taken = 0.002765
Prover Time taken = 0.003053
Prover Time taken = 0.00281
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002582
Prover Time taken = 0.002797
Prover Time taken = 0.002997
Prover Time taken = 0.002615
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
Prover Time taken = 0.002696
Prover Time taken = 0.002318
Prover Time taken = 0.002879
Prover Time taken = 0.002898
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.003282
Prover Time taken = 0.002669
Prover Time taken = 0.002965
Prover Time taken = 0.002235
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
Prover Time taken = 0.002089
Prover Time taken = 0.001184
Prover Time taken = 0.001429
Prover Time taken = 0.001669
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
Prover Time taken = 0.000967
Prover Time taken = 0.001101
Prover Time taken = 0.000947
Prover Time taken = 0.001281
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.001036
Prover Time taken = 0.001125
Prover Time taken = 0.001163
Prover Time taken = 0.001179
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && flag2 <= 0) || (x <= -1 && 0 < flag1 && flag2 <= 1 && flag1 <= 1 && 0 < flag2 && 0 < turn && turn - flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.003688
Added Horn clause: 326 => 327
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0686280
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && -1 < x + flag1 && x + flag2 <= 0 && 0 < turn && x + turn <= 1) || (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && -1 < x + flag1 && 0 < x + flag2 && 0 < x + turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.003102
Prover Time taken = 0.002682
Prover Time taken = 0.002526
Prover Time taken = 0.002677
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && -1 < x + flag1 && x + flag2 <= 0 && 0 < turn && x + turn <= 1) || (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && -1 < x + flag1 && 0 < x + flag2 && 0 < x + turn) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && -1 < x - flag1 && x <= 1 && flag2 <= 0) || (0 < flag1 && -1 < x - flag1 && x <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn)
}
Prover Time taken = 0.007858
Added Horn clause: 327 => 55
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0920080
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 1 < turn && 0 < flag1)
}
Prover Time taken = 0.001429
Prover Time taken = 0.001431
Prover Time taken = 0.001513
Prover Time taken = 0.001451
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 0 < turn
}
Prover Time taken = 0.001676
Prover Time taken = 0.001239
Prover Time taken = 0.00122
Prover Time taken = 0.001209
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 || (1 < turn && x <= 0)
}
Prover Time taken = 0.001305
Prover Time taken = 0.001271
Prover Time taken = 0.001316
Prover Time taken = 0.001257
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 0 < turn
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000989
Prover Time taken = 0.000909
Prover Time taken = 0.00106
Prover Time taken = 0.000893
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 0 < turn
}
Prover Time taken = 0.001126
Prover Time taken = 0.001217
Prover Time taken = 0.001303
Prover Time taken = 0.001621
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 1 < turn && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 0 < turn
}
Prover Time taken = 0.005075
Added Horn clause: 328 => 53
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0630520
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 1 < turn && 0 < turn - flag2)
}
Prover Time taken = 0.001767
Prover Time taken = 0.001453
Prover Time taken = 0.001212
Prover Time taken = 0.001272
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 1 < turn && 0 < turn - flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 0 < turn
}
Prover Time taken = 0.003876
Added Horn clause: 329 => 262
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0697340
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && 0 < turn - flag1)
}
Prover Time taken = 0.00177
Prover Time taken = 0.00127
Prover Time taken = 0.001111
Prover Time taken = 0.001822
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 0 < turn
}
Prover Time taken = 0.002739
Prover Time taken = 0.004456
Added Horn clause: 330 => 331
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0788930
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
Prover Time taken = 0.00219
Prover Time taken = 0.001527
Prover Time taken = 0.001689
Prover Time taken = 0.002232
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 0 < turn
}
Prover Time taken = 0.002301
Prover Time taken = 0.001952
Prover Time taken = 0.001894
Prover Time taken = 0.002217
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 0 < turn
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002318
Prover Time taken = 0.00208
Prover Time taken = 0.002466
Prover Time taken = 0.002376
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 0 < turn
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 || (1 < turn && x <= 0)
}
Prover Time taken = 0.005851
Added Horn clause: 128 && 332 => 96
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0702210
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1
}
Prover Time taken = 0.001693
Prover Time taken = 0.002269
Prover Time taken = 0.00165
Prover Time taken = 0.001395
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001494
Prover Time taken = 0.001225
Prover Time taken = 0.001237
Prover Time taken = 0.001242
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1
}
Prover Time taken = 0.001562
Prover Time taken = 0.001607
Prover Time taken = 0.001475
Prover Time taken = 0.001458
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1
}
Prover Time taken = 0.001816
Prover Time taken = 0.002644
Prover Time taken = 0.002265
Prover Time taken = 0.002297
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003444
Added Horn clause: 66 && 188 => 333
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0777050
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && 1 < turn + flag2) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 1 < turn + flag2)
}
Prover Time taken = 0.00206
Prover Time taken = 0.00199
Prover Time taken = 0.004876
Prover Time taken = 0.001994
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 1 < turn + flag2
}
Prover Time taken = 0.001144
Prover Time taken = 0.001425
Prover Time taken = 0.001029
Prover Time taken = 0.001596
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 1 < turn + flag2
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001016
Prover Time taken = 0.000947
Prover Time taken = 0.001319
Prover Time taken = 0.001067
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 1 < turn + flag2
}
Prover Time taken = 0.001386
Prover Time taken = 0.001144
Prover Time taken = 0.001209
Prover Time taken = 0.001436
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && 1 < turn + flag2) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 1 < turn + flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 1 < turn + flag2
}
Prover Time taken = 0.002549
Prover Time taken = 0.003203
Prover Time taken = 0.003728
Prover Time taken = 0.002268
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 1 < turn + flag2
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001807
Prover Time taken = 0.001728
Prover Time taken = 0.002184
Prover Time taken = 0.00179
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && 1 < turn + flag2
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 || (1 < turn && x <= 0)
}
Prover Time taken = 0.004235
Added Horn clause: 334 && 335 => 249
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0694940
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
Prover Time taken = 0.001715
Prover Time taken = 0.001401
Prover Time taken = 0.001377
Prover Time taken = 0.001649
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
Prover Time taken = 0.001174
Prover Time taken = 0.000984
Prover Time taken = 0.001075
Prover Time taken = 0.000991
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001003
Prover Time taken = 0.001065
Prover Time taken = 0.000934
Prover Time taken = 0.000896
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
Prover Time taken = 0.001376
Prover Time taken = 0.001064
Prover Time taken = 0.001258
Prover Time taken = 0.001347
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
Prover Time taken = 0.001728
Prover Time taken = 0.001487
Prover Time taken = 0.002619
Prover Time taken = 0.002644
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002452
Prover Time taken = 0.002745
Prover Time taken = 0.001959
Prover Time taken = 0.002729
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 || (1 < turn && x <= 0)
}
Prover Time taken = 0.002629
Prover Time taken = 0.002924
Prover Time taken = 0.002801
Prover Time taken = 0.002605
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.002008
Prover Time taken = 0.00132
Prover Time taken = 0.0013
Prover Time taken = 0.001998
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
Prover Time taken = 0.001219
Prover Time taken = 0.001185
Prover Time taken = 0.001382
Prover Time taken = 0.001584
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 || (1 < turn && x <= 0)
}
Prover Time taken = 0.001238
Prover Time taken = 0.000841
Prover Time taken = 0.000771
Prover Time taken = 0.000865
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 || (1 < turn && x <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.001097
Prover Time taken = 0.001011
Prover Time taken = 0.001221
Prover Time taken = 0.001199
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && x <= 0 && 0 < flag1 && flag1 <= 1 && 0 < turn)
}
Prover Time taken = 0.004254
Added Horn clause: 336 => 337
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0785360
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 1 < turn && flag1 <= 1)
}
Prover Time taken = 0.002225
Prover Time taken = 0.001861
Prover Time taken = 0.0017
Prover Time taken = 0.001843
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 1 < turn && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
Prover Time taken = 0.002392
Prover Time taken = 0.002041
Prover Time taken = 0.002347
Prover Time taken = 0.00243
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 1 < turn && flag1 <= 1)
}
Prover Time taken = 0.001387
Prover Time taken = 0.001238
Prover Time taken = 0.001192
Prover Time taken = 0.001024
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 1 < turn && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003698
Added Horn clause: 308 && 338 => 29
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0769170
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
Prover Time taken = 0.001678
Prover Time taken = 0.001342
Prover Time taken = 0.001604
Prover Time taken = 0.003866
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
Prover Time taken = 0.002038
Prover Time taken = 0.002079
Prover Time taken = 0.002161
Prover Time taken = 0.001955
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
Prover Time taken = 0.001221
Prover Time taken = 0.001335
Prover Time taken = 0.000889
Prover Time taken = 0.000839
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002338
Prover Time taken = 0.001753
Prover Time taken = 0.001823
Prover Time taken = 0.002602
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 || (1 < turn && x <= 0)
}
Prover Time taken = 0.002378
Prover Time taken = 0.002451
Prover Time taken = 0.002674
Prover Time taken = 0.002524
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.002102
Prover Time taken = 0.001874
Prover Time taken = 0.001837
Prover Time taken = 0.002037
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
Prover Time taken = 0.001542
Prover Time taken = 0.00145
Prover Time taken = 0.001288
Prover Time taken = 0.001421
Verifying P0_stable_t2_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001119
Prover Time taken = 0.001096
Prover Time taken = 0.001271
Prover Time taken = 0.001634
Verifying P0_stable_t2_s2: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 || (1 < turn && x <= 0)
}
Prover Time taken = 0.001551
Prover Time taken = 0.001398
Prover Time taken = 0.001269
Prover Time taken = 0.001291
Verifying Q0_stable_t1_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000981
Prover Time taken = 0.001068
Prover Time taken = 0.000816
Prover Time taken = 0.000914
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001712
Prover Time taken = 0.001697
Prover Time taken = 0.001638
Prover Time taken = 0.001741
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 || (1 < turn && x <= 0)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
Prover Time taken = 0.006101
Added Horn clause: 339 && 54 => 305
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0753060
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && x + flag1 <= -1 && flag2 <= 0) || (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && -1 < x + flag1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
Prover Time taken = 0.002644
Prover Time taken = 0.001768
Prover Time taken = 0.002284
Prover Time taken = 0.00213
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && x + flag1 <= -1 && flag2 <= 0) || (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && -1 < x + flag1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
Prover Time taken = 0.002465
Prover Time taken = 0.002348
Prover Time taken = 0.001932
Prover Time taken = 0.001769
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && x + flag1 <= -1 && flag2 <= 0) || (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && -1 < x + flag1) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
Prover Time taken = 0.003846
Added Horn clause: 340 => 341
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0730420
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && flag2 <= 1) || (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && 1 < flag2 && 0 < x + turn) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
Prover Time taken = 0.002229
Prover Time taken = 0.001812
Prover Time taken = 0.001405
Prover Time taken = 0.001869
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && flag2 <= 1) || (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && 1 < flag2 && 0 < x + turn) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag1 && -1 < x - flag1 && -1 < turn - flag1 && x <= 1
}
Prover Time taken = 0.003453
Prover Time taken = 0.002143
Prover Time taken = 0.002091
Prover Time taken = 0.002522
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && flag2 <= 1) || (x <= -1 && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1 && 1 < flag2 && 0 < x + turn) || (-1 < x && 0 < flag1 && -1 < turn - flag1 && flag1 <= 1)
}
Prover Time taken = 0.004001
Added Horn clause: 342 => 54
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0834450
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && 0 < flag1)
}
Prover Time taken = 0.001601
Prover Time taken = 0.001526
Prover Time taken = 0.001583
Prover Time taken = 0.001338
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag1 <= -1 && flag1 + flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag1 <= -1 && 0 < flag1 + flag2 && flag1 - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && -1 < turn - flag1) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.001889
Prover Time taken = 0.001449
Prover Time taken = 0.001445
Prover Time taken = 0.001492
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001665
Prover Time taken = 0.001511
Prover Time taken = 0.001483
Prover Time taken = 0.001541
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag1 <= -1 && flag1 + flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag1 <= -1 && 0 < flag1 + flag2 && flag1 - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && -1 < turn - flag1) || (0 < flag1 && -1 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002361
Prover Time taken = 0.002077
Prover Time taken = 0.001547
Prover Time taken = 0.001631
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag1 <= -1 && flag1 + flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag1 <= -1 && 0 < flag1 + flag2 && flag1 - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && -1 < turn - flag1) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.001818
Prover Time taken = 0.00212
Prover Time taken = 0.001725
Prover Time taken = 0.001416
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag1 <= -1 && flag1 + flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag1 <= -1 && 0 < flag1 + flag2 && flag1 - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && -1 < turn - flag1) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.004987
Added Horn clause: 343 => 344
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0742120
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag2 <= 0 && flag1 - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && 0 < turn - flag2) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.001921
Prover Time taken = 0.00183
Prover Time taken = 0.002038
Prover Time taken = 0.001974
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag2 <= 0 && flag1 - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && 0 < turn - flag2) || (0 < flag1 && -1 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001237
Prover Time taken = 0.00116
Prover Time taken = 0.001499
Prover Time taken = 0.001394
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag2 <= 0 && flag1 - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && 0 < turn - flag2) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.003688
Prover Time taken = 0.001871
Prover Time taken = 0.001405
Prover Time taken = 0.001576
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && 0 < flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && 0 < x && turn - flag2 <= 0 && flag1 - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x && 0 < turn - flag2) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.004218
Added Horn clause: 345 => 76
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0729830
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && flag1 <= 1 && turn - flag2 <= -1 && x - turn <= 0) || (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && turn - flag2 <= 0 && 0 < flag1 - flag2) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.001811
Prover Time taken = 0.002198
Prover Time taken = 0.001473
Prover Time taken = 0.002152
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001372
Prover Time taken = 0.001333
Prover Time taken = 0.001267
Prover Time taken = 0.001373
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && flag1 <= 1 && turn - flag2 <= -1 && x - turn <= 0) || (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && turn - flag2 <= 0 && 0 < flag1 - flag2) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001486
Prover Time taken = 0.001511
Prover Time taken = 0.001686
Prover Time taken = 0.001189
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && flag1 <= 1 && turn - flag2 <= -1 && x - turn <= 0) || (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && turn - flag2 <= 0 && 0 < flag1 - flag2) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
Added: P2:-2,-2,1,2: negative
Prover Time taken = 0.005112
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0835950
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && flag1 <= 1 && -1 < x + flag1 && turn - flag2 <= -1 && x - turn <= 0) || (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && turn - flag2 <= 0 && 0 < flag1 - flag2) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.002474
Prover Time taken = 0.002948
Prover Time taken = 0.001989
Prover Time taken = 0.002543
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && flag1 <= 1 && -1 < x + flag1 && turn - flag2 <= -1 && x - turn <= 0) || (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && turn - flag2 <= 0 && 0 < flag1 - flag2) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002161
Prover Time taken = 0.002255
Prover Time taken = 0.001672
Prover Time taken = 0.00164
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && flag1 <= 1 && -1 < x + flag1 && turn - flag2 <= -1 && x - turn <= 0) || (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && turn - flag2 <= 0 && 0 < flag1 - flag2) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
Added: P2:-1,-1,1,0: negative
Prover Time taken = 0.004564
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.1114560
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && flag1 <= 1 && 0 < x + flag2 && flag2 <= 1 && turn <= 0) || (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && turn - flag2 <= 0 && 0 < flag1 - flag2) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.002038
Prover Time taken = 0.001681
Prover Time taken = 0.002507
Prover Time taken = 0.001834
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && flag1 <= 1 && 0 < x + flag2 && flag2 <= 1 && turn <= 0) || (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && turn - flag2 <= 0 && 0 < flag1 - flag2) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001446
Prover Time taken = 0.001696
Prover Time taken = 0.002042
Prover Time taken = 0.002064
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && flag1 <= 1 && 0 < x + flag2 && flag2 <= 1 && turn <= 0) || (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && turn - flag2 <= 0 && 0 < flag1 - flag2) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
Added: P2:0,-2,1,1: negative
Prover Time taken = 0.003897
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0775880
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.00261
Prover Time taken = 0.002623
Prover Time taken = 0.002505
Prover Time taken = 0.001711
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.002555
Prover Time taken = 0.001975
Prover Time taken = 0.002107
Prover Time taken = 0.0019
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001114
Prover Time taken = 0.001287
Prover Time taken = 0.000964
Prover Time taken = 0.000977
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003426
Prover Time taken = 0.001967
Prover Time taken = 0.001498
Prover Time taken = 0.001546
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.001754
Prover Time taken = 0.001429
Prover Time taken = 0.001299
Prover Time taken = 0.002048
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.003207
Prover Time taken = 0.003137
Prover Time taken = 0.003249
Prover Time taken = 0.002899
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003026
Prover Time taken = 0.003209
Prover Time taken = 0.003655
Prover Time taken = 0.004358
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.004165
Prover Time taken = 0.003455
Prover Time taken = 0.002878
Prover Time taken = 0.002781
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.002615
Prover Time taken = 0.002483
Prover Time taken = 0.002168
Prover Time taken = 0.001977
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.00209
Prover Time taken = 0.001532
Prover Time taken = 0.002231
Prover Time taken = 0.00172
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001465
Prover Time taken = 0.001023
Prover Time taken = 0.001005
Prover Time taken = 0.00085
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.001293
Prover Time taken = 0.001235
Prover Time taken = 0.002258
Prover Time taken = 0.001022
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.000979
Prover Time taken = 0.001073
Prover Time taken = 0.001077
Prover Time taken = 0.001096
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002096
Prover Time taken = 0.002173
Prover Time taken = 0.001976
Prover Time taken = 0.001991
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002512
Prover Time taken = 0.002582
Prover Time taken = 0.002826
Prover Time taken = 0.002679
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.002345
Prover Time taken = 0.002567
Prover Time taken = 0.002423
Prover Time taken = 0.002135
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001694
Prover Time taken = 0.001821
Prover Time taken = 0.001317
Prover Time taken = 0.00139
Verifying P0_stable_t2_s2: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001154
Prover Time taken = 0.001359
Prover Time taken = 0.001665
Prover Time taken = 0.001359
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002474
Prover Time taken = 0.001912
Prover Time taken = 0.002576
Prover Time taken = 0.001853
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001582
Prover Time taken = 0.001569
Prover Time taken = 0.00218
Prover Time taken = 0.001933
Verifying Q1_stable_t1_s1: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001377
Prover Time taken = 0.001471
Prover Time taken = 0.001016
Prover Time taken = 0.00104
Verifying Q1_stable_t1_s3: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.003459
Prover Time taken = 0.001619
Prover Time taken = 0.001882
Prover Time taken = 0.001751
Verifying not_Q1_stable_t1_s1: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001243
Prover Time taken = 0.001189
Prover Time taken = 0.001473
Prover Time taken = 0.001186
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001698
Prover Time taken = 0.001507
Prover Time taken = 0.001788
Prover Time taken = 0.00163
Verifying not_Q1_stable_t1_s3: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.001816
Prover Time taken = 0.002073
Prover Time taken = 0.001891
Prover Time taken = 0.001844
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002307
Prover Time taken = 0.001944
Prover Time taken = 0.00195
Prover Time taken = 0.00197
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.003932
Added Horn clause: 349 && 350 => 351
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0682000
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < turn - flag1
}
Prover Time taken = 0.001107
Prover Time taken = 0.001044
Prover Time taken = 0.001177
Prover Time taken = 0.000845
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < turn - flag1
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000769
Prover Time taken = 0.003148
Prover Time taken = 0.000676
Prover Time taken = 0.001038
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < turn - flag1
}
Added: Q2:2,2,-2,-2: negative
Prover Time taken = 0.0035
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0704240
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < turn + flag2
}
Prover Time taken = 0.000832
Prover Time taken = 0.0009
Prover Time taken = 0.000751
Prover Time taken = 0.00072
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < turn + flag2
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000623
Prover Time taken = 0.000876
Prover Time taken = 0.000893
Prover Time taken = 0.000794
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < turn + flag2
}
Added: Q2:2,2,2,-1: negative
Prover Time taken = 0.002397
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0661760
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn - flag2 <= 0
}
Prover Time taken = 0.000981
Prover Time taken = 0.000785
Prover Time taken = 0.000815
Prover Time taken = 0.001133
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn - flag2 <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000861
Prover Time taken = 0.000706
Prover Time taken = 0.000567
Prover Time taken = 0.00059
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn - flag2 <= 0
}
Added: Q2:2,-2,2,-2: negative
Prover Time taken = 0.002091
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0661740
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -1 < flag2
}
Prover Time taken = 0.001061
Prover Time taken = 0.000857
Prover Time taken = 0.000888
Prover Time taken = 0.00084
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -1 < flag2
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000643
Prover Time taken = 0.000598
Prover Time taken = 0.000625
Prover Time taken = 0.000623
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  -1 < flag2
}
Added: Q2:1,2,-2,0: negative
Prover Time taken = 0.003481
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0608890
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
Prover Time taken = 0.000827
Prover Time taken = 0.000768
Prover Time taken = 0.000699
Prover Time taken = 0.000663
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000578
Prover Time taken = 0.000534
Prover Time taken = 0.000517
Prover Time taken = 0.000692
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2
}
Added: Q2:1,2,2,2: negative
Prover Time taken = 0.002118
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0595530
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < x + turn && flag1 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001881
Prover Time taken = 0.001227
Prover Time taken = 0.001834
Prover Time taken = 0.001728
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000798
Prover Time taken = 0.000634
Prover Time taken = 0.000629
Prover Time taken = 0.000734
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000787
Prover Time taken = 0.000614
Prover Time taken = 0.000582
Prover Time taken = 0.000601
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000606
Prover Time taken = 0.000515
Prover Time taken = 0.000659
Prover Time taken = 0.000613
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < x + turn && flag1 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.002066
Prover Time taken = 0.001937
Prover Time taken = 0.001912
Prover Time taken = 0.001955
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.001843
Prover Time taken = 0.00221
Prover Time taken = 0.002346
Prover Time taken = 0.002253
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000877
Prover Time taken = 0.000714
Prover Time taken = 0.000839
Prover Time taken = 0.000826
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000837
Prover Time taken = 0.000775
Prover Time taken = 0.000848
Prover Time taken = 0.000812
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < x + turn && flag1 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001445
Prover Time taken = 0.002241
Prover Time taken = 0.000877
Prover Time taken = 0.00099
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < x + turn && flag1 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003978
Added Horn clause: 54 && 357 => 246
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0601840
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && -1 < turn - flag2) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001393
Prover Time taken = 0.001364
Prover Time taken = 0.000874
Prover Time taken = 0.000865
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && -1 < turn - flag2) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.002769
Prover Time taken = 0.002212
Prover Time taken = 0.001658
Prover Time taken = 0.001714
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && -1 < turn - flag2) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001255
Prover Time taken = 0.002431
Added Horn clause: 358 => 359
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0709050
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001323
Prover Time taken = 0.0015
Prover Time taken = 0.001656
Prover Time taken = 0.00178
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.002077
Prover Time taken = 0.002082
Prover Time taken = 0.002088
Prover Time taken = 0.002143
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001061
Prover Time taken = 0.001069
Prover Time taken = 0.000925
Prover Time taken = 0.000955
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002071
Prover Time taken = 0.002352
Prover Time taken = 0.002643
Prover Time taken = 0.002707
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002572
Prover Time taken = 0.001718
Prover Time taken = 0.002491
Prover Time taken = 0.002345
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.002237
Prover Time taken = 0.002166
Prover Time taken = 0.002028
Prover Time taken = 0.002161
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001231
Prover Time taken = 0.001169
Prover Time taken = 0.001524
Prover Time taken = 0.001114
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00185
Prover Time taken = 0.001914
Prover Time taken = 0.001684
Prover Time taken = 0.001832
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001417
Prover Time taken = 0.001601
Prover Time taken = 0.001748
Prover Time taken = 0.00153
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001463
Prover Time taken = 0.001418
Prover Time taken = 0.002031
Prover Time taken = 0.001469
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002508
Prover Time taken = 0.002214
Prover Time taken = 0.001851
Prover Time taken = 0.002413
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.002913
Added Horn clause: 360 && 26 => 361
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0600690
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001098
Prover Time taken = 0.001039
Prover Time taken = 0.001002
Prover Time taken = 0.002427
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && x - turn <= 0
}
Prover Time taken = 0.000732
Prover Time taken = 0.000921
Prover Time taken = 0.000752
Prover Time taken = 0.000684
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && x - turn <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000771
Prover Time taken = 0.000661
Prover Time taken = 0.000582
Prover Time taken = 0.00079
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && x - turn <= 0
}
Added: Q2:1,1,2,2: negative
Prover Time taken = 0.002539
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0604740
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && flag1 <= 0
}
Prover Time taken = 0.001075
Prover Time taken = 0.000849
Prover Time taken = 0.000666
Prover Time taken = 0.001091
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && flag1 <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000695
Prover Time taken = 0.000498
Prover Time taken = 0.000547
Prover Time taken = 0.000649
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && flag1 <= 0
}
Added: Q2:2,-2,-2,-2: negative
Prover Time taken = 0.002661
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0580740
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - turn <= 0 && turn <= 1 && flag1 + flag2 <= 1
}
Prover Time taken = 0.003179
Prover Time taken = 0.000955
Prover Time taken = 0.001007
Prover Time taken = 0.000792
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - turn <= 0 && turn <= 1 && flag1 + flag2 <= 1
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00087
Prover Time taken = 0.000811
Prover Time taken = 0.000773
Prover Time taken = 0.000769
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - turn <= 0 && turn <= 1 && flag1 + flag2 <= 1
}
Added: Q2:1,1,2,-2: negative
Prover Time taken = 0.002462
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0580380
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && x + turn <= -1 && 0 < flag2 && flag2 <= 1) || (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && -1 < x + turn) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001746
Prover Time taken = 0.001631
Prover Time taken = 0.001494
Prover Time taken = 0.001534
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.001704
Prover Time taken = 0.001062
Prover Time taken = 0.000772
Prover Time taken = 0.000741
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000619
Prover Time taken = 0.000479
Prover Time taken = 0.000454
Prover Time taken = 0.000655
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000584
Prover Time taken = 0.000492
Prover Time taken = 0.000591
Prover Time taken = 0.000639
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && x + turn <= -1 && 0 < flag2 && flag2 <= 1) || (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && -1 < x + turn) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.002184
Prover Time taken = 0.002092
Prover Time taken = 0.002232
Prover Time taken = 0.002189
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.00407
Prover Time taken = 0.00226
Prover Time taken = 0.001562
Prover Time taken = 0.002129
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.00063
Prover Time taken = 0.000538
Prover Time taken = 0.000534
Prover Time taken = 0.000807
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.000638
Prover Time taken = 0.000741
Prover Time taken = 0.000691
Prover Time taken = 0.000651
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && x + turn <= -1 && 0 < flag2 && flag2 <= 1) || (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && -1 < x + turn) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001092
Prover Time taken = 0.001044
Prover Time taken = 0.001073
Prover Time taken = 0.001026
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && x + turn <= -1 && 0 < flag2 && flag2 <= 1) || (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && -1 < x + turn) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002171
Prover Time taken = 0.002004
Prover Time taken = 0.002045
Prover Time taken = 0.002056
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && x + turn <= -1 && 0 < flag2 && flag2 <= 1) || (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && -1 < x + turn) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002116
Prover Time taken = 0.001973
Prover Time taken = 0.001969
Prover Time taken = 0.002096
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && x + turn <= -1 && 0 < flag2 && flag2 <= 1) || (x <= -1 && 0 < flag1 && turn - flag1 <= 0 && -1 < turn - flag1 && turn <= 1 && -1 < x + turn) || (x <= -1 && 0 < flag1 && 0 < turn - flag1 && turn - flag1 <= 1 && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0
}
Prover Time taken = 0.00345
Added Horn clause: 246 && 365 => 26
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0573590
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001095
Prover Time taken = 0.001019
Prover Time taken = 0.00086
Prover Time taken = 0.000971
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x <= 1 && turn <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001105
Prover Time taken = 0.000888
Prover Time taken = 0.00066
Prover Time taken = 0.000846
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x <= 1 && turn <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000658
Prover Time taken = 0.000621
Prover Time taken = 0.000639
Prover Time taken = 0.000629
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x <= 1 && turn <= 1 && flag1 <= 1)
}
Added: Q2:1,-2,-2,-2: negative
Prover Time taken = 0.003098
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0579620
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag1 - flag2 <= -1 && turn - flag2 <= 0
}
Prover Time taken = 0.001126
Prover Time taken = 0.000869
Prover Time taken = 0.000886
Prover Time taken = 0.000948
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag1 - flag2 <= -1 && turn - flag2 <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000811
Prover Time taken = 0.000709
Prover Time taken = 0.000627
Prover Time taken = 0.000755
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag1 - flag2 <= -1 && turn - flag2 <= 0
}
Added: Q2:2,-2,-2,-1: negative
Prover Time taken = 0.002535
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0579340
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - flag1 <= 0 && flag1 <= 1)
}
Prover Time taken = 0.001067
Prover Time taken = 0.00076
Prover Time taken = 0.000786
Prover Time taken = 0.000753
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - flag1 <= 0 && flag1 <= 1)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000635
Prover Time taken = 0.000623
Prover Time taken = 0.000668
Prover Time taken = 0.00065
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - flag1 <= 0 && flag1 <= 1)
}
Added: Q2:1,-2,1,-2: negative
Prover Time taken = 0.002317
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0568500
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001425
Prover Time taken = 0.000946
Prover Time taken = 0.00093
Prover Time taken = 0.00124
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - flag2 <= 1 && 0 < flag1 - flag2)
}
Prover Time taken = 0.00094
Prover Time taken = 0.000848
Prover Time taken = 0.001208
Prover Time taken = 0.001147
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - flag2 <= 1 && 0 < flag1 - flag2)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000725
Prover Time taken = 0.000568
Prover Time taken = 0.00055
Prover Time taken = 0.000635
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - flag2 <= 1 && 0 < flag1 - flag2)
}
Added: Q2:1,-2,1,0: negative
Prover Time taken = 0.002616
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0568430
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001308
Prover Time taken = 0.001002
Prover Time taken = 0.000875
Prover Time taken = 0.000885
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && flag1 <= 1)
}
Prover Time taken = 0.000992
Prover Time taken = 0.000868
Prover Time taken = 0.000998
Prover Time taken = 0.000795
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001244
Prover Time taken = 0.000825
Prover Time taken = 0.000714
Prover Time taken = 0.000609
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && flag1 <= 1)
}
Added: Q2:1,1,-2,2: negative
Prover Time taken = 0.002084
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0657020
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && -1 < x + flag1 && flag1 <= 1)
}
Prover Time taken = 0.001163
Prover Time taken = 0.000879
Prover Time taken = 0.000942
Prover Time taken = 0.001057
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && -1 < x + flag1 && flag1 <= 1)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000789
Prover Time taken = 0.000915
Prover Time taken = 0.00066
Prover Time taken = 0.000663
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && -1 < x + flag1 && flag1 <= 1)
}
Overwrote: Q2:1,1,1,2: negative
Prover Time taken = 0.00237
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0615960
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001245
Prover Time taken = 0.001025
Prover Time taken = 0.001021
Prover Time taken = 0.001526
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && flag2 <= 0 && 0 < flag1 + flag2)
}
Prover Time taken = 0.000917
Prover Time taken = 0.001118
Prover Time taken = 0.001229
Prover Time taken = 0.000775
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && flag2 <= 0 && 0 < flag1 + flag2)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000686
Prover Time taken = 0.000762
Prover Time taken = 0.000668
Prover Time taken = 0.000688
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && flag2 <= 0 && 0 < flag1 + flag2)
}
Added: Q2:1,1,2,0: negative
Prover Time taken = 0.002158
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0616640
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && -1 < x + flag1 && flag1 <= 1 && flag2 <= 0)
}
Prover Time taken = 0.001028
Prover Time taken = 0.002072
Prover Time taken = 0.000823
Prover Time taken = 0.001116
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && -1 < x + flag1 && flag1 <= 1 && flag2 <= 0)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000779
Prover Time taken = 0.000699
Prover Time taken = 0.00064
Prover Time taken = 0.000665
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && -1 < x + flag1 && flag1 <= 1 && flag2 <= 0)
}
Added: Q2:1,1,-1,-2: negative
Prover Time taken = 0.002385
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0620200
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && flag2 <= 0 && -1 < x + flag2 && flag1 <= 1)
}
Prover Time taken = 0.00105
Prover Time taken = 0.001006
Prover Time taken = 0.000818
Prover Time taken = 0.000747
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && flag2 <= 0 && -1 < x + flag2 && flag1 <= 1)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000979
Prover Time taken = 0.001008
Prover Time taken = 0.000779
Prover Time taken = 0.000748
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && flag2 <= 0 && -1 < x + flag2 && flag1 <= 1)
}
Added: Q2:1,1,-2,-1: negative
Prover Time taken = 0.002367
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0590650
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && 0 < x + flag1 && flag1 <= 1 && flag2 <= 0)
}
Prover Time taken = 0.001413
Prover Time taken = 0.001197
Prover Time taken = 0.000866
Prover Time taken = 0.000851
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && 0 < x + flag1 && flag1 <= 1 && flag2 <= 0)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000721
Prover Time taken = 0.000621
Prover Time taken = 0.000717
Prover Time taken = 0.000728
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 || (0 < x && x - turn <= 0 && turn <= 1 && 0 < x + flag1 && flag1 <= 1 && flag2 <= 0)
}
Overwrote: Q2:1,1,1,0: negative
Prover Time taken = 0.002413
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0548580
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001115
Prover Time taken = 0.000978
Prover Time taken = 0.000797
Prover Time taken = 0.00076
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && flag1 <= 0
}
Prover Time taken = 0.000661
Prover Time taken = 0.000844
Prover Time taken = 0.000643
Prover Time taken = 0.000654
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && flag1 <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000539
Prover Time taken = 0.000489
Prover Time taken = 0.000488
Prover Time taken = 0.000579
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && flag1 <= 0
}
Prover Time taken = 0.000575
Prover Time taken = 0.000477
Prover Time taken = 0.000617
Prover Time taken = 0.000796
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.001787
Prover Time taken = 0.001721
Prover Time taken = 0.001992
Prover Time taken = 0.001572
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && flag1 <= 0
}
Prover Time taken = 0.003068
Prover Time taken = 0.001873
Prover Time taken = 0.001537
Prover Time taken = 0.001684
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x <= 0 && flag1 <= 0
}
Prover Time taken = 0.002108
Added Horn clause: 374 => 375
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0585160
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && 0 < turn - flag1)
}
Prover Time taken = 0.00134
Prover Time taken = 0.000966
Prover Time taken = 0.000927
Prover Time taken = 0.00095
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000826
Prover Time taken = 0.000865
Prover Time taken = 0.00077
Prover Time taken = 0.000877
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && 0 < turn - flag1)
}
Prover Time taken = 0.000764
Prover Time taken = 0.000793
Prover Time taken = 0.000819
Prover Time taken = 0.000782
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && 0 < turn - flag1)
}
Prover Time taken = 0.002126
Prover Time taken = 0.002587
Prover Time taken = 0.001776
Prover Time taken = 0.00239
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && 0 < turn - flag1)
}
Prover Time taken = 0.002833
Added Horn clause: 376 => 377
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0609170
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && x - turn <= -1 && 0 < turn - flag1) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.001088
Prover Time taken = 0.000975
Prover Time taken = 0.000831
Prover Time taken = 0.000859
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && x - turn <= -1 && 0 < turn - flag1) || (x <= 0 && -1 < x - turn)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000855
Prover Time taken = 0.000804
Prover Time taken = 0.000743
Prover Time taken = 0.000775
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && x - turn <= -1 && 0 < turn - flag1) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.000983
Prover Time taken = 0.000922
Prover Time taken = 0.001535
Prover Time taken = 0.001528
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && x - turn <= -1 && 0 < turn - flag1) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.003892
Prover Time taken = 0.00316
Prover Time taken = 0.002092
Prover Time taken = 0.002526
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn - flag1 <= 0 && 1 < turn) || (x <= 0 && x - turn <= -1 && 0 < turn - flag1) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.002393
Added Horn clause: 378 => 379
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0601050
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn <= 1 && flag1 <= 0) || (x <= 0 && x - turn <= -1 && turn <= 1 && 0 < flag1 && 1 < flag1) || (x <= 0 && x - turn <= -1 && 1 < turn) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.001094
Prover Time taken = 0.001134
Prover Time taken = 0.000953
Prover Time taken = 0.000841
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn <= 1 && flag1 <= 0) || (x <= 0 && x - turn <= -1 && turn <= 1 && 0 < flag1 && 1 < flag1) || (x <= 0 && x - turn <= -1 && 1 < turn) || (x <= 0 && -1 < x - turn)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00095
Prover Time taken = 0.000803
Prover Time taken = 0.000744
Prover Time taken = 0.001003
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn <= 1 && flag1 <= 0) || (x <= 0 && x - turn <= -1 && turn <= 1 && 0 < flag1 && 1 < flag1) || (x <= 0 && x - turn <= -1 && 1 < turn) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.001035
Prover Time taken = 0.001102
Prover Time taken = 0.001028
Prover Time taken = 0.00099
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn <= 1 && flag1 <= 0) || (x <= 0 && x - turn <= -1 && turn <= 1 && 0 < flag1 && 1 < flag1) || (x <= 0 && x - turn <= -1 && 1 < turn) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.002791
Prover Time taken = 0.00258
Prover Time taken = 0.00221
Prover Time taken = 0.002723
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn <= 1 && flag1 <= 0) || (x <= 0 && x - turn <= -1 && turn <= 1 && 0 < flag1 && 1 < flag1) || (x <= 0 && x - turn <= -1 && 1 < turn) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.001392
Prover Time taken = 0.001794
Prover Time taken = 0.001454
Prover Time taken = 0.001456
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn <= 1 && flag1 <= 0) || (x <= 0 && x - turn <= -1 && turn <= 1 && 0 < flag1 && 1 < flag1) || (x <= 0 && x - turn <= -1 && 1 < turn) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.001039
Prover Time taken = 0.000849
Prover Time taken = 0.000967
Prover Time taken = 0.00104
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.000746
Prover Time taken = 0.000835
Prover Time taken = 0.000795
Prover Time taken = 0.000721
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001385
Prover Time taken = 0.001287
Prover Time taken = 0.001279
Prover Time taken = 0.001371
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001675
Prover Time taken = 0.001892
Prover Time taken = 0.001749
Prover Time taken = 0.003937
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn <= 1 && flag1 <= 0) || (x <= 0 && x - turn <= -1 && turn <= 1 && 0 < flag1 && 1 < flag1) || (x <= 0 && x - turn <= -1 && 1 < turn) || (x <= 0 && -1 < x - turn)
}
Prover Time taken = 0.002083
Prover Time taken = 0.001965
Prover Time taken = 0.00196
Prover Time taken = 0.001861
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001008
Prover Time taken = 0.000967
Prover Time taken = 0.000971
Prover Time taken = 0.000811
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001722
Prover Time taken = 0.001652
Prover Time taken = 0.001817
Prover Time taken = 0.001666
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001479
Prover Time taken = 0.001604
Prover Time taken = 0.001438
Prover Time taken = 0.001947
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001374
Prover Time taken = 0.001235
Prover Time taken = 0.0012
Prover Time taken = 0.001341
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002136
Prover Time taken = 0.0014
Prover Time taken = 0.00157
Prover Time taken = 0.001771
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && x - turn <= -1 && turn <= 1 && flag1 <= 0) || (x <= 0 && x - turn <= -1 && turn <= 1 && 0 < flag1 && 1 < flag1) || (x <= 0 && x - turn <= -1 && 1 < turn) || (x <= 0 && -1 < x - turn)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.004057
Added Horn clause: 380 && 54 => 381
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0611090
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && 1 < flag1)
}
Prover Time taken = 0.001113
Prover Time taken = 0.000841
Prover Time taken = 0.000866
Prover Time taken = 0.000897
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && 1 < flag1)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001028
Prover Time taken = 0.000804
Prover Time taken = 0.00073
Prover Time taken = 0.000722
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && 1 < flag1)
}
Prover Time taken = 0.000895
Prover Time taken = 0.000837
Prover Time taken = 0.001407
Prover Time taken = 0.001034
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && 1 < flag1)
}
Prover Time taken = 0.001972
Prover Time taken = 0.001937
Prover Time taken = 0.001834
Prover Time taken = 0.001743
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && 1 < flag1)
}
Prover Time taken = 0.002356
Added Horn clause: 382 => 383
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0611760
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x + flag1)
}
Prover Time taken = 0.000894
Prover Time taken = 0.000785
Prover Time taken = 0.000751
Prover Time taken = 0.000742
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x + flag1)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000695
Prover Time taken = 0.000749
Prover Time taken = 0.001927
Prover Time taken = 0.000725
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x + flag1)
}
Prover Time taken = 0.000723
Prover Time taken = 0.00077
Prover Time taken = 0.00071
Prover Time taken = 0.000693
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x + flag1)
}
Prover Time taken = 0.002005
Prover Time taken = 0.001921
Prover Time taken = 0.001822
Prover Time taken = 0.001817
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x + flag1)
}
Prover Time taken = 0.000955
Prover Time taken = 0.000891
Prover Time taken = 0.00092
Prover Time taken = 0.000942
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x + flag1)
}
Prover Time taken = 0.000843
Prover Time taken = 0.000807
Prover Time taken = 0.000757
Prover Time taken = 0.000804
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x + flag1)
}
Prover Time taken = 0.001525
Prover Time taken = 0.001658
Prover Time taken = 0.001788
Prover Time taken = 0.001788
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x + flag1)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.002976
Added Horn clause: 384 && 247 => 351
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0672620
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
Prover Time taken = 0.000889
Prover Time taken = 0.000791
Prover Time taken = 0.000708
Prover Time taken = 0.000909
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000985
Prover Time taken = 0.000909
Prover Time taken = 0.000709
Prover Time taken = 0.000887
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
Prover Time taken = 0.000968
Prover Time taken = 0.000847
Prover Time taken = 0.000862
Prover Time taken = 0.001348
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
Prover Time taken = 0.002008
Prover Time taken = 0.001855
Prover Time taken = 0.001702
Prover Time taken = 0.001873
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
Prover Time taken = 0.000734
Prover Time taken = 0.000646
Prover Time taken = 0.000746
Prover Time taken = 0.000694
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
Prover Time taken = 0.000735
Prover Time taken = 0.000724
Prover Time taken = 0.000814
Prover Time taken = 0.000734
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
Prover Time taken = 0.001824
Prover Time taken = 0.001449
Prover Time taken = 0.001341
Prover Time taken = 0.001384
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.00337
Added Horn clause: 385 && 386 => 351
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0664570
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag2 <= 1)
}
Prover Time taken = 0.001015
Prover Time taken = 0.000832
Prover Time taken = 0.000827
Prover Time taken = 0.001355
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag2 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.003168
Added Horn clause: 387 => 307
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0623210
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1 && 0 < turn - flag2)
}
Prover Time taken = 0.00121
Prover Time taken = 0.000988
Prover Time taken = 0.001099
Prover Time taken = 0.000988
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1 && 0 < turn - flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.001646
Prover Time taken = 0.001709
Prover Time taken = 0.0016
Prover Time taken = 0.001834
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1 && 0 < turn - flag2)
}
Prover Time taken = 0.002027
Added Horn clause: 388 => 308
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0595320
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && -1 < turn - flag2)
}
Prover Time taken = 0.001042
Prover Time taken = 0.000945
Prover Time taken = 0.000983
Prover Time taken = 0.000891
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && -1 < turn - flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.001993
Prover Time taken = 0.001967
Prover Time taken = 0.001933
Prover Time taken = 0.001979
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && -1 < turn - flag2)
}
Prover Time taken = 0.001807
Prover Time taken = 0.002725
Added Horn clause: 389 => 390
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0599700
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.001118
Prover Time taken = 0.00098
Prover Time taken = 0.000966
Prover Time taken = 0.001065
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.001835
Prover Time taken = 0.001824
Prover Time taken = 0.001694
Prover Time taken = 0.003086
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.000875
Prover Time taken = 0.000732
Prover Time taken = 0.000975
Prover Time taken = 0.001156
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00222
Prover Time taken = 0.001528
Prover Time taken = 0.002197
Prover Time taken = 0.001492
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002235
Prover Time taken = 0.002159
Prover Time taken = 0.002145
Prover Time taken = 0.001616
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
Prover Time taken = 0.001734
Prover Time taken = 0.002158
Prover Time taken = 0.001593
Prover Time taken = 0.002239
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.001077
Prover Time taken = 0.001844
Prover Time taken = 0.001447
Prover Time taken = 0.001294
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001888
Prover Time taken = 0.001814
Prover Time taken = 0.001579
Prover Time taken = 0.001829
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.001711
Prover Time taken = 0.001586
Prover Time taken = 0.00151
Prover Time taken = 0.001225
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.001461
Prover Time taken = 0.001384
Prover Time taken = 0.001601
Prover Time taken = 0.00141
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002437
Prover Time taken = 0.002196
Prover Time taken = 0.002457
Prover Time taken = 0.002269
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.003595
Added Horn clause: 391 && 287 => 392
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0640260
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && x - flag2 <= -1 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.001903
Prover Time taken = 0.001379
Prover Time taken = 0.000968
Prover Time taken = 0.00106
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && x - flag2 <= -1 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.002068
Prover Time taken = 0.00175
Prover Time taken = 0.001861
Prover Time taken = 0.001875
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && x - flag2 <= -1 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.000979
Prover Time taken = 0.001029
Prover Time taken = 0.002127
Prover Time taken = 0.001089
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && x - flag2 <= -1 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00354
Added Horn clause: 393 && 394 => 395
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0660380
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.001437
Prover Time taken = 0.001234
Prover Time taken = 0.001204
Prover Time taken = 0.00122
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.002048
Prover Time taken = 0.001882
Prover Time taken = 0.0019
Prover Time taken = 0.00183
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.001006
Prover Time taken = 0.001078
Prover Time taken = 0.000981
Prover Time taken = 0.000923
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002286
Prover Time taken = 0.001652
Prover Time taken = 0.002323
Prover Time taken = 0.001686
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002225
Prover Time taken = 0.002882
Prover Time taken = 0.00198
Prover Time taken = 0.002408
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
Prover Time taken = 0.003032
Prover Time taken = 0.00245
Prover Time taken = 0.002377
Prover Time taken = 0.002411
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.001195
Prover Time taken = 0.001136
Prover Time taken = 0.001042
Prover Time taken = 0.001049
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002315
Prover Time taken = 0.002264
Prover Time taken = 0.00214
Prover Time taken = 0.002246
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.00184
Prover Time taken = 0.001703
Prover Time taken = 0.001712
Prover Time taken = 0.001767
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.00193
Prover Time taken = 0.001831
Prover Time taken = 0.001622
Prover Time taken = 0.001843
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002649
Prover Time taken = 0.002922
Prover Time taken = 0.002485
Prover Time taken = 0.003441
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= 0 && flag1 <= 0) || (x <= 0 && 0 < flag1 && -1 < x)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && turn - flag1 <= 0 && -1 < turn + flag2 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1 && 0 < turn - flag1)
}
Prover Time taken = 0.003108
Added Horn clause: 396 && 397 => 398
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0644210
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001043
Prover Time taken = 0.001791
Prover Time taken = 0.000802
Prover Time taken = 0.000883
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2 && flag2 <= 1
}
Prover Time taken = 0.000972
Prover Time taken = 0.000857
Prover Time taken = 0.000884
Prover Time taken = 0.001026
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2 && flag2 <= 1
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000816
Prover Time taken = 0.000994
Prover Time taken = 0.000905
Prover Time taken = 0.000935
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2 && flag2 <= 1
}
Added: Q2:2,2,2,1: negative
Prover Time taken = 0.002069
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0675390
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && turn - flag2 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && 0 < turn - flag2 && 0 < flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x - turn)
}
Prover Time taken = 0.001245
Prover Time taken = 0.000953
Prover Time taken = 0.000894
Prover Time taken = 0.001099
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && turn - flag2 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && 0 < turn - flag2 && 0 < flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x - turn)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001536
Prover Time taken = 0.001089
Prover Time taken = 0.000866
Prover Time taken = 0.000794
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && turn - flag2 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && 0 < turn - flag2 && 0 < flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x - turn)
}
Prover Time taken = 0.001283
Prover Time taken = 0.001259
Prover Time taken = 0.000989
Prover Time taken = 0.001081
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
Prover Time taken = 0.001777
Prover Time taken = 0.002289
Prover Time taken = 0.002564
Prover Time taken = 0.002324
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && turn - flag1 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && flag2 <= 0) || (1 < turn + flag1 && 0 < x && flag1 <= 1 && turn - flag1 <= 1 && 0 < turn - flag1 && 0 < flag2 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && turn - flag2 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && 0 < turn - flag2 && 0 < flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x - turn)
}
Prover Time taken = 0.002135
Prover Time taken = 0.001984
Prover Time taken = 0.002353
Prover Time taken = 0.002039
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && turn - flag2 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && 0 < turn - flag2 && 0 < flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x - turn)
}
Prover Time taken = 0.001378
Prover Time taken = 0.001192
Prover Time taken = 0.001344
Prover Time taken = 0.001509
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && turn - flag2 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && 0 < turn - flag2 && 0 < flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x - turn)
}
Prover Time taken = 0.001575
Prover Time taken = 0.001102
Prover Time taken = 0.00147
Prover Time taken = 0.001754
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.000849
Prover Time taken = 0.000847
Prover Time taken = 0.000836
Prover Time taken = 0.001055
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001698
Prover Time taken = 0.001595
Prover Time taken = 0.004324
Prover Time taken = 0.001702
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001405
Prover Time taken = 0.001445
Prover Time taken = 0.001255
Prover Time taken = 0.00138
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && turn - flag2 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && 0 < turn - flag2 && 0 < flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x - turn)
}
Prover Time taken = 0.00156
Prover Time taken = 0.001504
Prover Time taken = 0.001593
Prover Time taken = 0.002161
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001088
Prover Time taken = 0.001324
Prover Time taken = 0.001419
Prover Time taken = 0.001372
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001584
Prover Time taken = 0.001616
Prover Time taken = 0.001705
Prover Time taken = 0.001475
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001668
Prover Time taken = 0.001834
Prover Time taken = 0.001217
Prover Time taken = 0.001187
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.001746
Prover Time taken = 0.001985
Prover Time taken = 0.002761
Prover Time taken = 0.001787
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001635
Prover Time taken = 0.001779
Prover Time taken = 0.002413
Prover Time taken = 0.002081
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && turn - flag2 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && x - turn <= -1 && 0 < turn - flag2 && 0 < flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x - turn)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && turn - flag1 <= 1 && flag1 <= 1)
}
Prover Time taken = 0.003895
Added Horn clause: 365 && 246 => 400
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0801420
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2 && flag2 <= 1 && x - flag2 <= 0
}
Prover Time taken = 0.001364
Prover Time taken = 0.001168
Prover Time taken = 0.001129
Prover Time taken = 0.00224
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2 && flag2 <= 1 && x - flag2 <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001101
Prover Time taken = 0.001089
Prover Time taken = 0.000995
Prover Time taken = 0.001055
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < flag2 && flag2 <= 1 && x - flag2 <= 0
}
Added: Q2:1,-2,2,1: negative
Prover Time taken = 0.00351
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.1002880
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag2 && flag2 <= 1 && x <= 0) || (0 < flag2 && flag2 <= 1 && 0 < x && flag1 - flag2 <= 0)
}
Prover Time taken = 0.001305
Prover Time taken = 0.001396
Prover Time taken = 0.001244
Prover Time taken = 0.001371
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag2 && flag2 <= 1 && x <= 0) || (0 < flag2 && flag2 <= 1 && 0 < x && flag1 - flag2 <= 0)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000934
Prover Time taken = 0.001024
Prover Time taken = 0.001787
Prover Time taken = 0.001341
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag2 && flag2 <= 1 && x <= 0) || (0 < flag2 && flag2 <= 1 && 0 < x && flag1 - flag2 <= 0)
}
Added: Q2:1,2,1,1: negative
Prover Time taken = 0.003943
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0942360
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag2 && flag2 <= 1 && x <= 0) || (0 < flag2 && flag2 <= 1 && 0 < x && flag1 - flag2 <= 0 && turn - flag1 <= 0)
}
Prover Time taken = 0.001628
Prover Time taken = 0.001238
Prover Time taken = 0.001498
Prover Time taken = 0.002023
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag2 && flag2 <= 1 && x <= 0) || (0 < flag2 && flag2 <= 1 && 0 < x && flag1 - flag2 <= 0 && turn - flag1 <= 0)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001573
Prover Time taken = 0.001955
Prover Time taken = 0.001317
Prover Time taken = 0.00129
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag2 && flag2 <= 1 && x <= 0) || (0 < flag2 && flag2 <= 1 && 0 < x && flag1 - flag2 <= 0 && turn - flag1 <= 0)
}
Added: Q2:1,-2,-2,1: negative
Prover Time taken = 0.003993
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.1239090
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag2 && flag2 <= 1 && x <= 0) || (0 < flag2 && flag2 <= 1 && 0 < x && x - turn <= 0 && turn - flag2 <= 0)
}
Prover Time taken = 0.001395
Prover Time taken = 0.001146
Prover Time taken = 0.001134
Prover Time taken = 0.003061
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag2 && flag2 <= 1 && x <= 0) || (0 < flag2 && flag2 <= 1 && 0 < x && x - turn <= 0 && turn - flag2 <= 0)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001183
Prover Time taken = 0.001152
Prover Time taken = 0.001085
Prover Time taken = 0.00104
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag2 && flag2 <= 1 && x <= 0) || (0 < flag2 && flag2 <= 1 && 0 < x && x - turn <= 0 && turn - flag2 <= 0)
}
Added: Q2:1,1,-2,1: negative
Prover Time taken = 0.004572
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0935920
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn)
}
Prover Time taken = 0.001225
Prover Time taken = 0.001083
Prover Time taken = 0.001284
Prover Time taken = 0.002111
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && x - flag2 <= -1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && -1 < x - flag2 && flag1 + flag2 <= 0)
}
Prover Time taken = 0.00139
Prover Time taken = 0.001292
Prover Time taken = 0.001357
Prover Time taken = 0.001743
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && turn - flag2 <= 0) || (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001182
Prover Time taken = 0.001009
Prover Time taken = 0.001103
Prover Time taken = 0.001137
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && 0 < flag2 && x <= 0 && flag2 <= 1 && -1 < x + turn
}
Prover Time taken = 0.001072
Prover Time taken = 0.001102
Prover Time taken = 0.001058
Prover Time taken = 0.001743
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && 0 < flag2 && x <= 0 && flag2 <= 1 && -1 < x + turn
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000852
Prover Time taken = 0.000755
Prover Time taken = 0.000715
Prover Time taken = 0.000795
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && x - flag2 <= -1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && -1 < x - flag2 && flag1 + flag2 <= 0)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002014
Prover Time taken = 0.001741
Prover Time taken = 0.001513
Prover Time taken = 0.003784
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && 0 < flag2 && x <= 0 && flag2 <= 1 && -1 < x + turn
}
Prover Time taken = 0.00136
Prover Time taken = 0.000887
Prover Time taken = 0.000893
Prover Time taken = 0.000984
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && x - flag2 <= -1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && -1 < x - flag2 && flag1 + flag2 <= 0)
}
Prover Time taken = 0.001644
Prover Time taken = 0.002382
Prover Time taken = 0.001491
Prover Time taken = 0.001739
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && x - flag2 <= -1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && -1 < x - flag2 && flag1 + flag2 <= 0)
}
Prover Time taken = 0.004506
Added Horn clause: 405 => 344
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0936410
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && x - flag2 <= -1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && -1 < x - flag2 && flag2 <= 0)
}
Prover Time taken = 0.001312
Prover Time taken = 0.001529
Prover Time taken = 0.00103
Prover Time taken = 0.000995
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && x - flag2 <= -1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && -1 < x - flag2 && flag2 <= 0)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00139
Prover Time taken = 0.001161
Prover Time taken = 0.001092
Prover Time taken = 0.001354
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && x - flag2 <= -1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && -1 < x - flag2 && flag2 <= 0)
}
Prover Time taken = 0.002136
Prover Time taken = 0.001374
Prover Time taken = 0.001336
Prover Time taken = 0.001034
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (1 < turn + flag1 && 0 < x && flag1 <= 1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && x - flag2 <= -1) || (1 < turn + flag1 && 0 < x && 1 < flag1 && -1 < x - flag2 && flag2 <= 0)
}
Prover Time taken = 0.004999
Added Horn clause: 406 => 76
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0878890
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && turn - flag2 <= -1 && 0 < turn - flag1) || (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1 && -1 < turn - flag2) || (-1 < x && 0 < flag1 && 0 < turn && flag1 <= 1 && x + turn <= 1 && flag2 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && flag1 <= 1 && 1 < x + turn)
}
Prover Time taken = 0.001825
Prover Time taken = 0.002311
Prover Time taken = 0.002721
Prover Time taken = 0.002773
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn + flag1 && 0 < x && flag1 <= 1
}
Prover Time taken = 0.001129
Prover Time taken = 0.000909
Prover Time taken = 0.001181
Prover Time taken = 0.00135
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 1 && 0 < flag2 && x <= 0) || (turn <= 1 && 0 < flag2 && 0 < x && -1 < turn - flag2 && x - flag1 <= 0)
}
Prover Time taken = 0.001329
Prover Time taken = 0.001096
Prover Time taken = 0.001571
Prover Time taken = 0.001188
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 1 && 0 < flag2 && x <= 0) || (turn <= 1 && 0 < flag2 && 0 < x && -1 < turn - flag2 && x - flag1 <= 0)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001316
Prover Time taken = 0.001217
Prover Time taken = 0.0011
Prover Time taken = 0.001173
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn + flag1 && 0 < x && flag1 <= 1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00101
Prover Time taken = 0.000892
Prover Time taken = 0.001141
Prover Time taken = 0.001125
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (turn <= 1 && 0 < flag2 && x <= 0) || (turn <= 1 && 0 < flag2 && 0 < x && -1 < turn - flag2 && x - flag1 <= 0)
}
Overwrote: Q2:1,1,1,1: negative
Prover Time taken = 0.004214
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0934590
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && flag1 <= 1)
}
Prover Time taken = 0.001712
Prover Time taken = 0.001503
Prover Time taken = 0.001544
Prover Time taken = 0.001586
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && 0 < turn - flag1 && x <= 0
}
Prover Time taken = 0.001311
Prover Time taken = 0.001164
Prover Time taken = 0.00146
Prover Time taken = 0.001415
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && 0 < turn - flag1 && x <= 0
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001472
Prover Time taken = 0.001398
Prover Time taken = 0.001527
Prover Time taken = 0.001348
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && 0 < turn - flag1 && x <= 0
}
Prover Time taken = 0.001226
Prover Time taken = 0.001063
Prover Time taken = 0.00147
Prover Time taken = 0.001225
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn + flag1 && 0 < x && flag1 <= 1
}
Prover Time taken = 0.001694
Prover Time taken = 0.001342
Prover Time taken = 0.001217
Prover Time taken = 0.001297
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && 0 < turn && flag1 <= 1) || (-1 < x && 0 < flag1 && 0 < turn && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn + flag1 && 0 < x && flag1 <= 1
}
Prover Time taken = 0.002115
Prover Time taken = 0.001852
Prover Time taken = 0.002144
Prover Time taken = 0.001787
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  1 < turn + flag1 && 0 < x && flag1 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.004647
Added Horn clause: 407 && 408 => 82
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.1044210
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1) || (-1 < x && 0 < flag1)
}
Prover Time taken = 0.00174
Prover Time taken = 0.00159
Prover Time taken = 0.001468
Prover Time taken = 0.001786
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && -1 < x && 0 < flag1 - flag2 && turn - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
Prover Time taken = 0.002171
Prover Time taken = 0.002178
Prover Time taken = 0.002095
Prover Time taken = 0.004523
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && turn - flag2 <= 0 && 0 < turn) || (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001716
Prover Time taken = 0.001711
Prover Time taken = 0.001328
Prover Time taken = 0.001595
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && -1 < x && 0 < flag1 - flag2 && turn - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002009
Prover Time taken = 0.001685
Prover Time taken = 0.001609
Prover Time taken = 0.00189
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < flag1 && x - flag1 <= -1 && x <= 0 && 1 < flag1 && -1 < x && 0 < flag1 - flag2 && turn - flag2 <= 0) || (0 < flag1 && x - flag1 <= -1 && 0 < x) || (0 < flag1 && -1 < x - flag1)
}
Overwrote: P2:0,1,2,1: negative
Prover Time taken = 0.004885
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.1099730
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn) || (-1 < x && x <= 0) || (-1 < x && 0 < x && 1 < x - flag2)
}
Prover Time taken = 0.001317
Prover Time taken = 0.001193
Prover Time taken = 0.001489
Prover Time taken = 0.001417
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn + flag2 <= 1) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && 1 < flag2) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.001846
Prover Time taken = 0.001568
Prover Time taken = 0.001522
Prover Time taken = 0.001693
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 1 < turn + flag2 && turn - flag2 <= 0) || (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 1 < turn + flag2 && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001585
Prover Time taken = 0.001591
Prover Time taken = 0.001433
Prover Time taken = 0.001462
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn + flag2 <= 1) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && 1 < flag2) || (0 < x && x <= 1 && 1 < turn)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001531
Prover Time taken = 0.001437
Prover Time taken = 0.001506
Prover Time taken = 0.003623
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn + flag2 <= 1) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && 1 < flag2) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.001499
Prover Time taken = 0.001808
Prover Time taken = 0.001542
Prover Time taken = 0.001609
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn) || (-1 < x && x <= 0) || (-1 < x && 0 < x && 1 < x - flag2)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn + flag2 <= 1) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && 1 < flag2) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.004143
Added Horn clause: 409 => 65
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0852560
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn) || (-1 < x && 0 < flag1 && flag1 <= 1)
}
Prover Time taken = 0.001238
Prover Time taken = 0.001197
Prover Time taken = 0.001294
Prover Time taken = 0.001178
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn) || (-1 < x && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn + flag2 <= 1) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && 1 < flag2) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.002184
Prover Time taken = 0.00215
Prover Time taken = 0.001525
Prover Time taken = 0.001923
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn + flag2 <= 1) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && flag2 <= 1 && 0 < flag1 && flag1 - flag2 <= 0) || (0 < x && x <= 1 && turn <= 1 && 1 < turn + flag2 && 1 < flag2) || (0 < x && x <= 1 && 1 < turn)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.004546
Added Horn clause: 218 && 410 => 51
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0837540
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn <= 0) || (0 < x && x <= 1 && turn <= 1 && 0 < turn && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.001379
Prover Time taken = 0.001005
Prover Time taken = 0.001134
Prover Time taken = 0.001159
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn <= 0) || (0 < x && x <= 1 && turn <= 1 && 0 < turn && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001203
Prover Time taken = 0.001144
Prover Time taken = 0.000999
Prover Time taken = 0.001052
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn <= 0) || (0 < x && x <= 1 && turn <= 1 && 0 < turn && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.001049
Prover Time taken = 0.001078
Prover Time taken = 0.001143
Prover Time taken = 0.001063
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn) || (-1 < x && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn <= 0) || (0 < x && x <= 1 && turn <= 1 && 0 < turn && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.001885
Prover Time taken = 0.00201
Prover Time taken = 0.001697
Prover Time taken = 0.001767
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && turn <= 0) || (0 < x && x <= 1 && turn <= 1 && 0 < turn && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003103
Added Horn clause: 185 && 184 => 51
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0983030
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.001391
Prover Time taken = 0.001459
Prover Time taken = 0.001126
Prover Time taken = 0.003772
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001342
Prover Time taken = 0.00128
Prover Time taken = 0.001311
Prover Time taken = 0.001279
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.001234
Prover Time taken = 0.000995
Prover Time taken = 0.00094
Prover Time taken = 0.000982
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn) || (-1 < x && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
Prover Time taken = 0.001506
Prover Time taken = 0.001945
Prover Time taken = 0.002031
Prover Time taken = 0.001652
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.003375
Added Horn clause: 262 && 411 => 65
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.1035110
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && 0 < flag1) || (0 < x && x <= 1 && 1 < turn && -1 < x + flag2)
}
Prover Time taken = 0.001721
Prover Time taken = 0.00151
Prover Time taken = 0.001753
Prover Time taken = 0.001718
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 0 < turn && turn - flag2 <= 0) || (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 0 < turn && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001425
Prover Time taken = 0.001288
Prover Time taken = 0.001283
Prover Time taken = 0.001673
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && 0 < flag1) || (0 < x && x <= 1 && 1 < turn && -1 < x + flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001517
Prover Time taken = 0.001497
Prover Time taken = 0.001395
Prover Time taken = 0.001353
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && 0 < flag1) || (0 < x && x <= 1 && 1 < turn && -1 < x + flag2)
}
Prover Time taken = 0.001254
Prover Time taken = 0.001457
Prover Time taken = 0.001252
Prover Time taken = 0.00311
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn) || (-1 < x && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && 0 < flag1) || (0 < x && x <= 1 && 1 < turn && -1 < x + flag2)
}
Prover Time taken = 0.004168
Added Horn clause: 412 => 413
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.1060930
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && flag1 <= 0 && turn + flag1 <= 0) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && 0 < flag1) || (0 < x && x <= 1 && 1 < turn && -1 < x + flag2)
}
Prover Time taken = 0.001675
Prover Time taken = 0.001337
Prover Time taken = 0.001489
Prover Time taken = 0.001382
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && flag1 <= 0 && turn + flag1 <= 0) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && 0 < flag1) || (0 < x && x <= 1 && 1 < turn && -1 < x + flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001167
Prover Time taken = 0.001136
Prover Time taken = 0.001118
Prover Time taken = 0.001534
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && flag1 <= 0 && turn + flag1 <= 0) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && 0 < flag1) || (0 < x && x <= 1 && 1 < turn && -1 < x + flag2)
}
Prover Time taken = 0.001687
Prover Time taken = 0.001652
Prover Time taken = 0.002178
Prover Time taken = 0.00155
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (x <= -1 && 1 < turn) || (-1 < x && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && turn <= 1 && 0 < flag1 && flag1 <= 1) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && flag1 <= 0 && turn + flag1 <= 0) || (0 < x && x <= 1 && 1 < turn && x + flag2 <= -1 && 0 < flag1) || (0 < x && x <= 1 && 1 < turn && -1 < x + flag2)
}
Prover Time taken = 0.003593
Added Horn clause: 414 => 262
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0866700
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1)
}
Prover Time taken = 0.001539
Prover Time taken = 0.001145
Prover Time taken = 0.001363
Prover Time taken = 0.001315
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
Prover Time taken = 0.001159
Prover Time taken = 0.000959
Prover Time taken = 0.000911
Prover Time taken = 0.00107
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.0008
Prover Time taken = 0.001012
Prover Time taken = 0.000716
Prover Time taken = 0.000698
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
Prover Time taken = 0.000817
Prover Time taken = 0.000799
Prover Time taken = 0.000788
Prover Time taken = 0.00088
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
Prover Time taken = 0.001184
Prover Time taken = 0.001076
Prover Time taken = 0.00118
Prover Time taken = 0.001402
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001046
Prover Time taken = 0.001187
Prover Time taken = 0.001302
Prover Time taken = 0.000981
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 0 < turn && turn - flag2 <= 0) || (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 0 < turn && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.001771
Prover Time taken = 0.002039
Prover Time taken = 0.001565
Prover Time taken = 0.002145
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  turn <= 1 && 0 < turn - flag1 && x <= 0
}
Prover Time taken = 0.001483
Prover Time taken = 0.002449
Prover Time taken = 0.001725
Prover Time taken = 0.001681
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
Prover Time taken = 0.00089
Prover Time taken = 0.00089
Prover Time taken = 0.000747
Prover Time taken = 0.000861
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 0 < turn && turn - flag2 <= 0) || (flag2 <= 1 && 0 < flag2 && -1 < x + flag2 && 0 < turn && 0 < turn - flag2 && x <= 0)
}
Prover Time taken = 0.002816
Added Horn clause: 415 => 416
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0815330
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && x + turn <= -1 && turn + flag1 <= -1) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && -1 < x + turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.001845
Prover Time taken = 0.001628
Prover Time taken = 0.001371
Prover Time taken = 0.00143
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && x + turn <= -1 && turn + flag1 <= -1) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && -1 < x + turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.002213
Prover Time taken = 0.002663
Prover Time taken = 0.002089
Prover Time taken = 0.002117
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && x + turn <= -1 && turn + flag1 <= -1) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && -1 < x + turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.003393
Added Horn clause: 417 => 418
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0847680
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && x + turn <= -1 && turn + flag1 <= 0) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && -1 < x + turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.001902
Prover Time taken = 0.001417
Prover Time taken = 0.001413
Prover Time taken = 0.001347
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && x + turn <= -1 && turn + flag1 <= 0) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && -1 < x + turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.002302
Prover Time taken = 0.002392
Prover Time taken = 0.001953
Prover Time taken = 0.002083
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && x + turn <= -1 && turn + flag1 <= 0) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && -1 < x + turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.002896
Added Horn clause: 419 => 420
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0757770
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && x + turn <= -1 && flag1 <= 0) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && -1 < x + turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.001298
Prover Time taken = 0.003388
Prover Time taken = 0.00131
Prover Time taken = 0.001807
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && x + turn <= -1 && flag1 <= 0) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && -1 < x + turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.00186
Prover Time taken = 0.002283
Prover Time taken = 0.002092
Prover Time taken = 0.001881
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && x + turn <= -1 && flag1 <= 0) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && -1 < x + turn) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.002663
Added Horn clause: 421 => 422
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0844350
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && flag1 - flag2 <= 0) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && 0 < flag1 - flag2 && 0 < x + flag1) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.001628
Prover Time taken = 0.001454
Prover Time taken = 0.00136
Prover Time taken = 0.001422
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  0 < x && x <= 1 && 0 < flag1 && flag1 <= 1
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && flag1 - flag2 <= 0) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && 0 < flag1 - flag2 && 0 < x + flag1) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.001878
Prover Time taken = 0.002021
Prover Time taken = 0.002095
Prover Time taken = 0.002083
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && flag1 - flag2 <= 0) || (flag2 <= 1 && 0 < flag2 && turn - flag2 <= 0 && 0 < turn && 0 < flag1 - flag2 && 0 < x + flag1) || (flag2 <= 1 && 0 < flag2 && 0 < turn - flag2 && turn - flag2 <= 1 && 0 < x + turn && x <= 0)
}
Prover Time taken = 0.003611
Added Horn clause: 423 => 378
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0830580
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && x <= 0 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < x)
}
Prover Time taken = 0.001582
Prover Time taken = 0.001052
Prover Time taken = 0.000986
Prover Time taken = 0.001012
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 1 < flag2)
}
Prover Time taken = 0.001332
Prover Time taken = 0.001385
Prover Time taken = 0.00125
Prover Time taken = 0.00135
Verifying P3_stable_t2_s2: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001025
Prover Time taken = 0.000866
Prover Time taken = 0.000809
Prover Time taken = 0.001155
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x + flag2
}
Prover Time taken = 0.000911
Prover Time taken = 0.000799
Prover Time taken = 0.00069
Prover Time taken = 0.00069
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x + flag2
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000635
Prover Time taken = 0.000591
Prover Time taken = 0.00066
Prover Time taken = 0.00067
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000917
Prover Time taken = 0.000805
Prover Time taken = 0.00086
Prover Time taken = 0.001017
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x + flag2
}
Prover Time taken = 0.000695
Prover Time taken = 0.000629
Prover Time taken = 0.000707
Prover Time taken = 0.000743
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 1 < flag2)
}
Prover Time taken = 0.001357
Prover Time taken = 0.001049
Prover Time taken = 0.0011
Prover Time taken = 0.001063
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && x <= 0 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < x)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 1 && 0 < flag2 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 1 < flag2)
}
Prover Time taken = 0.003323
Added Horn clause: 424 => 309
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0768580
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001017
Prover Time taken = 0.001103
Prover Time taken = 0.001013
Prover Time taken = 0.000927
Verifying Q3_stable_t1_s3: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.001176
Prover Time taken = 0.000947
Prover Time taken = 0.00098
Prover Time taken = 0.00099
Verifying atomic_t1_transition_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000921
Prover Time taken = 0.001158
Prover Time taken = 0.000772
Prover Time taken = 0.00078
Verifying assert_t1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.001232
Prover Time taken = 0.001244
Prover Time taken = 0.001049
Prover Time taken = 0.001091
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.001472
Prover Time taken = 0.001683
Prover Time taken = 0.001398
Prover Time taken = 0.001755
Verifying P2_stable_t2_s1: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001614
Prover Time taken = 0.001777
Prover Time taken = 0.002453
Prover Time taken = 0.001556
Verifying P2_stable_t2_s2: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.002402
Prover Time taken = 0.002019
Prover Time taken = 0.001733
Prover Time taken = 0.001726
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x + flag2
}
Prover Time taken = 0.001712
Prover Time taken = 0.001673
Prover Time taken = 0.001572
Prover Time taken = 0.002178
Verifying Q0_stable_t1_s3: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.001255
Prover Time taken = 0.000878
Prover Time taken = 0.000934
Prover Time taken = 0.001376
Verifying atomic_t2_transition_s1: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.000554
Prover Time taken = 0.000564
Prover Time taken = 0.000517
Prover Time taken = 0.000561
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x + flag2
}
Prover Time taken = 0.000957
Prover Time taken = 0.000892
Prover Time taken = 0.000792
Prover Time taken = 0.000844
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x + flag2
}
Prover Time taken = 0.001277
Prover Time taken = 0.000741
Prover Time taken = 0.000733
Prover Time taken = 0.00075
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.000796
Prover Time taken = 0.000617
Prover Time taken = 0.000698
Prover Time taken = 0.000741
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002986
Prover Time taken = 0.001318
Prover Time taken = 0.001696
Prover Time taken = 0.00134
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.0014
Prover Time taken = 0.001318
Prover Time taken = 0.001506
Prover Time taken = 0.001653
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x + flag2
}
Prover Time taken = 0.001333
Prover Time taken = 0.001479
Prover Time taken = 0.001397
Prover Time taken = 0.00135
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001198
Prover Time taken = 0.000982
Prover Time taken = 0.00114
Prover Time taken = 0.001326
Verifying P0_stable_t2_s2: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.000953
Prover Time taken = 0.000684
Prover Time taken = 0.000636
Prover Time taken = 0.000677
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001375
Prover Time taken = 0.001641
Prover Time taken = 0.001756
Prover Time taken = 0.001713
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001581
Prover Time taken = 0.001454
Prover Time taken = 0.001451
Prover Time taken = 0.001889
Verifying Q1_stable_t1_s1: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001241
Prover Time taken = 0.000923
Prover Time taken = 0.000838
Prover Time taken = 0.00113
Verifying Q1_stable_t1_s3: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.001456
Prover Time taken = 0.001233
Prover Time taken = 0.001165
Prover Time taken = 0.001495
Verifying not_Q1_stable_t1_s1: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001125
Prover Time taken = 0.000969
Prover Time taken = 0.000839
Prover Time taken = 0.00087
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001269
Prover Time taken = 0.001214
Prover Time taken = 0.00164
Prover Time taken = 0.001228
Verifying not_Q1_stable_t1_s3: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.001449
Prover Time taken = 0.00128
Prover Time taken = 0.001278
Prover Time taken = 0.001437
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001454
Prover Time taken = 0.002008
Prover Time taken = 0.001377
Prover Time taken = 0.00158
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x + flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.003354
Added Horn clause: 425 && 25 => 400
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0858600
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x
}
Prover Time taken = 0.001184
Prover Time taken = 0.00132
Prover Time taken = 0.00071
Prover Time taken = 0.000961
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.000782
Prover Time taken = 0.000836
Prover Time taken = 0.000802
Prover Time taken = 0.000786
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x
}
Prover Time taken = 0.000802
Prover Time taken = 0.000754
Prover Time taken = 0.000832
Prover Time taken = 0.000838
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x
}
Prover Time taken = 0.002196
Prover Time taken = 0.002065
Prover Time taken = 0.002158
Prover Time taken = 0.002168
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x
}
Prover Time taken = 0.001078
Prover Time taken = 0.001327
Prover Time taken = 0.001044
Prover Time taken = 0.002695
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x
}
Prover Time taken = 0.00093
Prover Time taken = 0.000882
Prover Time taken = 0.001047
Prover Time taken = 0.001139
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x
}
Prover Time taken = 0.001759
Prover Time taken = 0.001623
Prover Time taken = 0.001696
Prover Time taken = 0.001859
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  x - flag2 <= -1 && flag2 <= 1 && -1 < x
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.003017
Added Horn clause: 426 && 29 => 400
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0903440
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 1 < turn + flag2 && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001645
Prover Time taken = 0.001331
Prover Time taken = 0.00123
Prover Time taken = 0.001173
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag1 - flag2 <= 0 && turn - flag2 <= 0 && flag2 <= 1 && flag1 <= 0) || (x - flag2 <= -1 && flag1 - flag2 <= 0 && 0 < turn - flag2) || (x - flag2 <= -1 && 0 < flag1 - flag2)
}
Prover Time taken = 0.00128
Prover Time taken = 0.001255
Prover Time taken = 0.001175
Prover Time taken = 0.001187
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag1 - flag2 <= 0 && turn - flag2 <= 0 && flag2 <= 1 && flag1 <= 0) || (x - flag2 <= -1 && flag1 - flag2 <= 0 && 0 < turn - flag2) || (x - flag2 <= -1 && 0 < flag1 - flag2)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00109
Prover Time taken = 0.000821
Prover Time taken = 0.001135
Prover Time taken = 0.000903
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag1 - flag2 <= 0 && turn - flag2 <= 0 && flag2 <= 1 && flag1 <= 0) || (x - flag2 <= -1 && flag1 - flag2 <= 0 && 0 < turn - flag2) || (x - flag2 <= -1 && 0 < flag1 - flag2)
}
Prover Time taken = 0.00106
Added: Q2:3,-5,5,4: negative
Prover Time taken = 0.003037
Calling ../Boogie/Binaries/hice-dt -b -h /home/alexander/sharedData/uni/hice-dt/benchmarks/concurrentPrograms/peterson_true-unreach-call-OG.bpl
Total learner time was 00:00:00.0825650
Verifying Q3_stable_t1_s2: 
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001182
Prover Time taken = 0.001587
Prover Time taken = 0.001137
Prover Time taken = 0.000917
Verifying P3_stable_t2_s3: 
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
Prover Time taken = 0.001174
Prover Time taken = 0.001073
Prover Time taken = 0.001464
Prover Time taken = 0.001549
Verifying atomic_t2_transition_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001626
Prover Time taken = 0.001514
Prover Time taken = 0.001372
Prover Time taken = 0.00103
Verifying assert_t2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
Prover Time taken = 0.001351
Prover Time taken = 0.001317
Prover Time taken = 0.001178
Prover Time taken = 0.001433
Verifying atomic_t1_transition_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.001357
Prover Time taken = 0.001518
Prover Time taken = 0.002084
Prover Time taken = 0.001377
Verifying P2_stable_t2_s3: 
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
Prover Time taken = 0.004628
Prover Time taken = 0.003121
Prover Time taken = 0.002518
Prover Time taken = 0.003164
Verifying atomic_t2_transition_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
Prover Time taken = 0.001818
Prover Time taken = 0.001702
Prover Time taken = 0.001451
Prover Time taken = 0.001605
Verifying P0_stable_t2_s3: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
Prover Time taken = 0.001314
Prover Time taken = 0.001476
Prover Time taken = 0.00112
Prover Time taken = 0.001113
Verifying atomic_t1_transition_s1: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.000723
Prover Time taken = 0.000622
Prover Time taken = 0.00067
Prover Time taken = 0.000758
Verifying P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.001323
Prover Time taken = 0.001321
Prover Time taken = 0.001281
Prover Time taken = 0.001247
Verifying P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001426
Prover Time taken = 0.001377
Prover Time taken = 0.002174
Prover Time taken = 0.001791
Verifying P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
Prover Time taken = 0.002465
Prover Time taken = 0.003035
Prover Time taken = 0.002407
Prover Time taken = 0.002367
Verifying Q0_stable_t1_s2: 
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001043
Prover Time taken = 0.000934
Prover Time taken = 0.000808
Prover Time taken = 0.000878
Verifying not_P1_stable_t2_s1: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002009
Prover Time taken = 0.001267
Prover Time taken = 0.001411
Prover Time taken = 0.001667
Verifying Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001214
Prover Time taken = 0.001202
Prover Time taken = 0.001181
Prover Time taken = 0.001217
Verifying not_Q1_stable_t1_s2: 
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.001242
Prover Time taken = 0.001206
Prover Time taken = 0.001206
Prover Time taken = 0.001221
Verifying not_P1_stable_t2_s2: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
Prover Time taken = 0.001486
Prover Time taken = 0.001444
Prover Time taken = 0.001532
Prover Time taken = 0.001526
Verifying Q2_stable_t1_s2: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
Prover Time taken = 0.0026
Prover Time taken = 0.002411
Prover Time taken = 0.002746
Prover Time taken = 0.002678
Verifying Q2_stable_t1_s1: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.002102
Prover Time taken = 0.002012
Prover Time taken = 0.001966
Prover Time taken = 0.001968
Verifying Q2_stable_t1_s3: 
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
Prover Time taken = 0.002308
Prover Time taken = 0.003075
Prover Time taken = 0.003946
Prover Time taken = 0.002325
Verifying not_P1_stable_t2_s3: 
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
Prover Time taken = 0.001871
Prover Time taken = 0.001796
Prover Time taken = 0.00174
Prover Time taken = 0.00248
Verifying pre: 
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
Prover Time taken = 0.00053
Prover Time taken = 0.000682
Prover Time taken = 0.000665
Prover Time taken = 0.000483
Prover time = 14.17
Number of prover queries = 4894
Learner time = 11.57
Number of learner queries = 297
Total time: 70.92
Number of positive examples:3
Number of negative examples:74
Number of Horn clauses:221
function {:existential true} {:inline} P0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} P1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x <= -1 && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1) || (-1 < x && 0 < flag1 && flag1 <= 1 && 0 < turn && turn - flag1 <= 1)
}
function {:existential true} {:inline} P2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && flag2 <= 0) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && flag2 <= 1 && turn - flag1 <= 0 && 0 < turn) || (0 < x && x <= 1 && 0 < flag1 && flag1 <= 1 && 0 < flag2 && 1 < flag2)
}
function {:existential true} {:inline} P3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q0(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
function {:existential true} {:inline} Q1(x: int, turn: int, flag1: int, flag2: int) : bool
{
  flag2 <= 1 && 0 < flag2
}
function {:existential true} {:inline} Q2(x: int, turn: int, flag1: int, flag2: int) : bool
{
  (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && flag1 <= 0) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && turn - flag2 <= 0 && 0 < flag1 && 0 < flag1 - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && x - turn <= -1 && 0 < turn - flag2) || (x - flag2 <= -1 && flag2 <= 1 && -1 < x && -1 < x - turn)
}
function {:existential true} {:inline} Q3(x: int, turn: int, flag1: int, flag2: int) : bool
{
  true
}
verified

Boogie program verifier finished with 1 verified, 0 errors
